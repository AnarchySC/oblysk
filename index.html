<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Oblysk - Console Paste Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #242424;
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-placeholder: rgba(255, 255, 255, 0.3);
            --border-color: rgba(255, 255, 255, 0.1);
            --accent-primary: #5b5fc7;
            --accent-secondary: #2c307d;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            margin: 0;
            padding: 0;
        }

        html {
            background: var(--bg-primary);
        }

        .app-container {
            width: 100%;
            height: 100vh;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        /* Startup Loading Screen */
        .startup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .startup-overlay.hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }

        .startup-logo {
            font-size: 48px;
            margin-bottom: 20px;
            animation: startupPulse 2s ease-in-out infinite;
        }

        @keyframes startupPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .startup-text {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--accent-primary);
        }

        .startup-progress {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .startup-spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Header */
        .header {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            -webkit-app-region: drag;
            user-select: none;
            background: var(--bg-secondary);
        }

        .header button {
            -webkit-app-region: no-drag;
        }

        .app-logo {
            filter: drop-shadow(0 0 10px rgba(124, 58, 237, 0.5));
            animation: logoGlow 3s ease-in-out infinite;
        }

        @keyframes logoGlow {
            0%, 100% { filter: drop-shadow(0 0 10px rgba(124, 58, 237, 0.5)); }
            50% { filter: drop-shadow(0 0 20px rgba(124, 58, 237, 0.8)); }
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .app-name {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 3px;
            color: var(--text-secondary);
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            margin-left: 10px;
            transition: all 0.3s ease;
        }

        .status-indicator.error {
            background: var(--error);
        }

        .status-indicator.warning {
            background: var(--warning);
        }

        .status-indicator.working {
            background: var(--accent-primary);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }

        .window-controls {
            display: flex;
            gap: 8px;
        }

        .control-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .minimize-btn {
            background: #febc2e;
        }

        .close-btn {
            background: #ff5f57;
        }

        .control-btn:hover {
            opacity: 0.8;
        }

        /* Enhanced Debug Panel */
        .debug-panel {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--error);
            border-radius: 8px;
            padding: 10px;
            margin: 10px;
            font-size: 11px;
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }

        .debug-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--error);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-controls {
            display: flex;
            gap: 8px;
        }

        .debug-btn {
            padding: 2px 6px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 10px;
            cursor: pointer;
        }

        .debug-btn:hover {
            background: var(--accent-primary);
            color: white;
        }

        .debug-content {
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
        }

        .debug-entry {
            margin: 4px 0;
            padding: 4px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 1.3;
        }

        .debug-entry.debug-error {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid var(--error);
        }

        .debug-entry.debug-warn {
            background: rgba(245, 158, 11, 0.1);
            border-left: 3px solid var(--warning);
        }

        .debug-entry.debug-success {
            background: rgba(16, 185, 129, 0.1);
            border-left: 3px solid var(--success);
        }

        .debug-entry.debug-info {
            background: rgba(59, 130, 246, 0.1);
            border-left: 3px solid #3b82f6;
        }

        .debug-time {
            color: var(--text-placeholder);
            margin-right: 8px;
        }

        .debug-category {
            color: var(--accent-primary);
            font-weight: bold;
            margin-right: 8px;
        }

        .debug-message {
            color: var(--text-primary);
        }

        .debug-data {
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            margin-top: 4px;
            border-radius: 4px;
            font-size: 9px;
            overflow-x: auto;
        }

        /* Main content */
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 12px;
            overflow: hidden;
            min-height: 0;
        }

        /* Instructions with status */
        .instructions {
            background: rgba(91, 95, 199, 0.1);
            border-radius: 8px;
            padding: 10px;
            font-size: 10px;
            line-height: 1.5;
            color: var(--text-secondary);
            position: relative;
        }

        .hotkey {
            display: inline-block;
            background: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 10px;
            color: var(--accent-primary);
            margin: 0 2px;
        }

        /* Grid section */
        .grid-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 12px;
            transition: all 0.3s ease;
            overflow: hidden;
            flex-shrink: 0;
            flex-grow: 0;
            height: clamp(160px, 25vh, 220px);
        }

        .grid-section.collapsed {
            height: 35px;
            padding-bottom: 10px;
        }

        .section-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapse-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            padding: 0 5px;
            transition: transform 0.3s ease;
        }

        .collapse-btn:hover {
            color: var(--text-primary);
        }

        .grid-section.collapsed .collapse-btn #collapse-icon {
            transform: rotate(180deg);
            display: inline-block;
        }

        .paste-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 6px;
            margin-top: 4px;
            opacity: 1;
            transition: all 0.3s ease;
            width: 100%;
            height: calc(100% - 30px);
        }

        .grid-section.collapsed .paste-grid {
            opacity: 0;
            height: 0;
            margin-top: 0;
            overflow: hidden;
        }

        .grid-cell {
            position: relative;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            padding: 4px;
            transition: all 0.2s ease;
            overflow: hidden;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            user-select: none;
            pointer-events: auto;
            z-index: 1;
        }

        .grid-cell:hover {
            border-color: var(--accent-primary);
            transform: scale(1.02);
        }

        .grid-cell:hover .cell-name-display {
            color: var(--accent-primary);
            letter-spacing: 1px;
            transition: all 0.2s ease;
        }

        .grid-cell:hover .cell-name-display.empty {
            color: var(--text-secondary);
        }

        .grid-cell:active {
            transform: scale(0.95);
            transition: transform 0.1s ease;
        }

        .grid-cell.active {
            border-color: var(--accent-primary);
            background: rgba(91, 95, 199, 0.1);
        }

        .cell-name-display {
            font-size: 11px;
            color: var(--text-primary);
            text-align: center;
            margin: auto;
            word-wrap: break-word;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 4px;
        }

        .cell-name-display.empty {
            color: var(--text-placeholder);
            font-style: italic;
            font-size: 10px;
        }

        /* Visual indicator for cells with content */
        .grid-cell.cell-has-content {
            border-color: rgba(16, 185, 129, 0.5);
            background: rgba(16, 185, 129, 0.05);
        }

        .grid-cell.cell-has-content .cell-name-display {
            color: var(--success);
        }

        .grid-cell.cell-has-content::after {
            content: "🔒";
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 8px;
            opacity: 0.6;
        }

        .grid-cell.cell-encrypted::after {
            content: "🛡️";
            opacity: 0.8;
        }

        /* Notepad section */
        .notepad-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 15px;
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            min-height: 150px;
            overflow: hidden;
        }

        .notepad-section.expanded {
            flex: 2;
        }

        .notepad {
            width: 100%;
            flex: 1;
            overflow-y: auto;
            background: transparent;
            border: none;
            outline: none;
            color: var(--text-primary);
            font-family: 'SF Mono', 'Menlo', monospace;
            font-size: 13px;
            line-height: 1.6;
            padding: 8px;
            min-height: 200px;
        }

        .notepad:empty::before {
            content: attr(data-placeholder);
            color: var(--text-placeholder);
            pointer-events: none;
            position: absolute;
        }

        /* Bottom bar */
        .bottom-bar {
            height: 60px;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            gap: 20px;
            position: relative;
        }

        .paste-method {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .method-select {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 4px 8px;
            font-size: 11px;
            outline: none;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .speed-slider {
            width: 100px;
            height: 4px;
            background: var(--bg-primary);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Reverse Copy Panel */
        .reverse-copy-panel {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--success);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            display: none;
        }

        .reverse-copy-panel.active {
            display: block;
        }

        .reverse-copy-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--success);
            margin-bottom: 8px;
        }

        .reverse-copy-status {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .reverse-copy-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .reverse-copy-btn {
            padding: 4px 8px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reverse-copy-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .reverse-copy-btn.secondary {
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        /* Custom dialog styles */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 6000;
        }

        .dialog-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            min-width: 300px;
            max-width: 400px;
            color: var(--text-primary);
        }

        .dialog-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--accent-primary);
        }

        .dialog-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            margin-bottom: 15px;
            outline: none;
        }

        .dialog-input:focus {
            border-color: var(--accent-primary);
        }

        .dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .dialog-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .dialog-btn-primary {
            background: var(--accent-primary);
            color: white;
        }

        .dialog-btn-primary:hover {
            background: var(--accent-secondary);
        }

        .dialog-btn-secondary {
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .dialog-btn-secondary:hover {
            background: var(--border-color);
        }

        .toast {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 12px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            border: 1px solid var(--border-color);
            max-width: 300px;
            word-wrap: break-word;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
        }

        .toast.error {
            border-color: var(--error);
            background: rgba(239, 68, 68, 0.1);
        }

        .toast.warning {
            border-color: var(--warning);
            background: rgba(245, 158, 11, 0.1);
        }

        /* On-deck clipboard item styling */
        .clipboard-entry {
            border-bottom: 1px solid var(--border-color);
            padding: 8px 0;
            margin-bottom: 8px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .clipboard-entry.on-deck {
            background: rgba(91, 95, 199, 0.1);
            border: 1px solid var(--accent-primary);
            padding: 12px;
            margin: 4px 0;
            position: relative;
        }

        .clipboard-entry.on-deck::before {
            content: "🎯 ON-DECK";
            position: absolute;
            top: 4px;
            right: 8px;
            font-size: 8px;
            color: var(--accent-primary);
            font-weight: bold;
            letter-spacing: 1px;
        }

        .clipboard-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        /* Auto-capture toggle switch */
        .auto-toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px;
            border-radius: 6px;
            transition: background 0.2s ease;
        }

        .auto-toggle-container:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .toggle-switch {
            position: relative;
            width: 32px;
            height: 18px;
            background: var(--border-color);
            border-radius: 9px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--success);
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(14px);
        }

        .toggle-label {
            font-size: 10px;
            color: var(--text-secondary);
            user-select: none;
            transition: color 0.2s ease;
        }

        .toggle-switch.active + .toggle-label {
            color: var(--success);
        }

        /* Developer info button */
        .dev-info-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .dev-info-btn:hover {
            background: var(--accent-primary);
            color: white;
            transform: scale(1.1);
        }

        /* Developer info dialog */
        .dev-info-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .dev-info-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            min-width: 320px;
            max-width: 400px;
            color: var(--text-primary);
            position: relative;
        }

        .dev-info-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--accent-primary);
            text-align: center;
        }

        .dev-info-item {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            padding: 8px;
            border-radius: 6px;
            transition: background 0.2s ease;
        }

        .dev-info-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .dev-info-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .dev-info-link {
            color: var(--text-primary);
            text-decoration: none;
            font-size: 13px;
            flex: 1;
            transition: color 0.2s ease;
        }

        .dev-info-link:hover {
            color: var(--accent-primary);
        }

        .dev-info-close {
            position: absolute;
            top: 8px;
            right: 12px;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            transition: color 0.2s ease;
        }

        .dev-info-close:hover {
            color: var(--text-primary);
        }

        .donate-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 12px;
            font-weight: 600;
            display: inline-block;
            margin-top: 8px;
            transition: all 0.2s ease;
            text-align: center;
            width: 100%;
        }

        .donate-btn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        /* Security - Lock Screen */
        .lock-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d1b69 50%, #1a1a1a 100%);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5000;
            backdrop-filter: blur(10px);
        }

        .lock-content {
            text-align: center;
            color: var(--text-primary);
            max-width: 400px;
            padding: 40px;
        }

        .lock-icon {
            font-size: 48px;
            margin-bottom: 20px;
            animation: lockPulse 2s ease-in-out infinite;
        }

        @keyframes lockPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .lock-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--accent-primary);
        }

        .lock-subtitle {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .lock-input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
            margin-bottom: 20px;
            outline: none;
            text-align: center;
            transition: all 0.3s ease;
        }

        .lock-input:focus {
            border-color: var(--accent-primary);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 20px rgba(91, 95, 199, 0.3);
        }

        .lock-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .unlock-btn {
            width: 100%;
            padding: 12px 16px;
            background: var(--accent-primary);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .unlock-btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(91, 95, 199, 0.4);
        }

        .unlock-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .lock-error {
            color: var(--error);
            font-size: 12px;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .lock-error.show {
            opacity: 1;
        }

        /* Security Settings Panel */
        .security-settings {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .security-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            min-width: 400px;
            max-width: 500px;
            color: var(--text-primary);
            max-height: 80vh;
            overflow-y: auto;
        }

        .security-panel-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .security-setting {
            margin-bottom: 24px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .setting-label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .setting-description {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .setting-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
        }

        .setting-range {
            width: 100%;
            margin: 8px 0;
        }

        .range-value {
            text-align: center;
            font-size: 12px;
            color: var(--accent-primary);
            font-weight: 600;
        }

        .security-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .security-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .security-btn-primary {
            background: var(--accent-primary);
            color: white;
        }

        .security-btn-secondary {
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .security-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        /* Settings gear icon */
        .settings-btn {
            position: absolute;
            bottom: 8px;
            left: 8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .settings-btn:hover {
            background: var(--accent-primary);
            color: white;
            transform: scale(1.1) rotate(45deg);
        }

        /* Content masking and reveal */
        .masked-content {
            font-family: monospace;
            letter-spacing: 2px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .masked-content:hover {
            color: var(--accent-primary);
            transform: scale(1.02);
        }

        .revealed-content {
            background: rgba(91, 95, 199, 0.1);
            border: 1px solid var(--accent-primary);
            border-radius: 4px;
            padding: 2px 6px;
            animation: revealPulse 3s ease-in-out;
        }

        @keyframes revealPulse {
            0%, 100% { background: rgba(91, 95, 199, 0.1); }
            50% { background: rgba(91, 95, 199, 0.2); }
        }

        .peek-indicator {
            position: absolute;
            top: -20px;
            right: 0;
            background: var(--accent-primary);
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            animation: peekCountdown 3s linear;
            pointer-events: none;
        }

        @keyframes peekCountdown {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.8); }
        }

        .privacy-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            transition: background 0.2s ease;
            margin-left: 10px;
        }

        .privacy-toggle:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .privacy-icon {
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .privacy-toggle.enabled .privacy-icon {
            color: var(--success);
        }

        .clipboard-entry.masked .clipboard-content {
            filter: blur(4px);
            transition: filter 0.3s ease;
            cursor: pointer;
        }

        .clipboard-entry.masked:hover .clipboard-content {
            filter: blur(2px);
        }

        .clipboard-entry.revealed .clipboard-content {
            filter: none;
            background: rgba(91, 95, 199, 0.1);
            border-radius: 4px;
            padding: 4px;
        }

        .peek-tooltip {
            position: absolute;
            background: var(--bg-primary);
            border: 1px solid var(--accent-primary);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 11px;
            color: var(--text-primary);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            max-width: 200px;
            word-wrap: break-word;
        }

        .peek-tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Clipboard management warning */
        .clipboard-warning {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 16px;
            border-radius: 12px;
            max-width: 350px;
            z-index: 4000;
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.4s ease;
        }

        .clipboard-warning.show {
            transform: translateX(0);
            opacity: 1;
        }

        .clipboard-warning-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .clipboard-warning-message {
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 12px;
            opacity: 0.9;
        }

        .clipboard-warning-countdown {
            font-size: 11px;
            font-weight: 600;
            color: #fef3c7;
            margin-bottom: 12px;
        }

        .clipboard-warning-buttons {
            display: flex;
            gap: 8px;
        }

        .warning-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .warning-btn-primary {
            background: white;
            color: #d97706;
        }

        .warning-btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .warning-btn:hover {
            transform: translateY(-1px);
            opacity: 0.9;
        }

        /* Clipboard export modal */
        .export-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 4500;
        }

        .export-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            min-width: 400px;
            max-width: 600px;
            max-height: 80vh;
            color: var(--text-primary);
            overflow-y: auto;
        }

        .export-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .export-preview {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            margin-bottom: 16px;
            color: var(--text-secondary);
        }

        .export-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .export-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .export-btn-primary {
            background: var(--success);
            color: white;
        }

        .export-btn-secondary {
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .export-btn:hover {
            transform: translateY(-1px);
            opacity: 0.9;
        }

        /* Clipboard action buttons */
        .clipboard-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            justify-content: center;
        }

        .clipboard-action-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-primary);
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .clipboard-action-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
            transform: translateY(-1px);
        }

        .clipboard-timer {
            font-size: 10px;
            color: var(--text-placeholder);
            text-align: center;
            margin-top: 4px;
            font-family: monospace;
        }

        /* Responsive design for different screen sizes */
        @media (max-height: 600px) {
            .grid-section {
                height: clamp(140px, 20vh, 180px);
            }
        }

        @media (max-height: 400px) {
            .grid-section {
                height: clamp(120px, 18vh, 160px);
            }
            .cell-name-display {
                font-size: 9px;
            }
            .cell-name-display.empty {
                font-size: 8px;
            }
        }

        @media (min-height: 800px) {
            .grid-section {
                height: clamp(180px, 28vh, 260px);
            }
        }
    </style>
</head>
<body>
    <!-- Startup Loading Screen -->
    <div class="startup-overlay" id="startup-overlay">
        <div class="startup-logo">🚀</div>
        <div class="startup-text">Oblysk</div>
        <div class="startup-progress" id="startup-progress">Initializing...</div>
        <div class="startup-spinner"></div>
    </div>

    <div class="app-container">
        <!-- Enhanced Debug Panel -->
        <div class="debug-panel" id="debug-panel">
            <div class="debug-title">
                🔧 Debug Information
                <div class="debug-controls">
                    <button class="debug-btn" onclick="debugLogger.exportLogs()">Export</button>
                    <button class="debug-btn" onclick="clearDebugLogs()">Clear</button>
                    <button class="debug-btn" onclick="toggleDebugMode()">Hide</button>
                </div>
            </div>
            <div class="debug-content" id="debug-content">
                <div class="debug-entry debug-info">
                    <span class="debug-time">--:--:--</span>
                    <span class="debug-category">[startup]</span>
                    <span class="debug-message">Debug panel initialized</span>
                </div>
            </div>
        </div>

        <!-- Header -->
        <div class="header">
            <div class="logo-section">
                <svg class="app-logo" viewBox="0 0 60 80" width="20" height="26">
                    <defs>
                        <linearGradient id="logoGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#a855f7;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#6366f1;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <path d="M 5 70 L 25 10 Q 30 0 35 10 L 55 70 L 45 70 L 30 20 L 15 70 Z" 
                          fill="url(#logoGradient)" 
                          stroke="none"/>
                </svg>
                <div class="app-name">OBLYSK</div>
                <div class="status-indicator" id="status"></div>
            </div>
            <div class="window-controls">
                <button class="control-btn minimize-btn" onclick="minimizeApp()"></button>
                <button class="control-btn close-btn" onclick="closeApp()"></button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="content">
            <!-- Instructions -->
            <div class="instructions">
                <strong>📝</strong> Single-click cell to name it • <strong>🔒</strong> Double-click to store password/content • <strong>⌨️</strong> <span class="hotkey">Ctrl+Alt+[1-9]</span> to paste anywhere • <span class="hotkey">Ctrl+Alt+V</span> paste on-deck • <span class="hotkey">Ctrl+Alt+O</span> hide/show • <span class="hotkey">Ctrl+Alt+R</span> reverse copy
            </div>

            <!-- Reverse Copy Panel -->
            <div class="reverse-copy-panel" id="reverse-copy-panel">
                <div class="reverse-copy-title">🔄 Reverse Copy: Web Console → Local</div>
                <div class="reverse-copy-status" id="reverse-copy-status">
                    Ready to capture from web consoles. Press Ctrl+Alt+R to grab selected text.
                </div>
                <div class="reverse-copy-controls">
                    <button class="reverse-copy-btn" onclick="toggleReverseCapture()">
                        <span id="reverse-copy-toggle-text">Enable</span>
                    </button>
                    <button class="reverse-copy-btn secondary" onclick="testReverseCapture()">
                        Test
                    </button>
                    <button class="reverse-copy-btn secondary" onclick="closeReversePanel()">
                        Close
                    </button>
                </div>
            </div>

            <!-- Notepad Section (TOP - Resizable) -->
            <div class="notepad-section" id="notepad-section">
                <div class="section-title">
                    Copy Record
                    <span style="font-size: 10px; margin-left: 10px; color: var(--text-secondary); display: flex; align-items: center; gap: 15px;">
                        <span id="clipboard-status">●</span>
                        <div class="auto-toggle-container" onclick="toggleAutoCapture()" title="Toggle automatic clipboard capture">
                            <div class="toggle-switch active" id="auto-toggle">
                                <div class="toggle-slider"></div>
                            </div>
                            <span class="toggle-label" id="auto-label">Auto</span>
                        </div>
                        <div class="privacy-toggle" onclick="toggleContentMasking()" title="Toggle content masking for privacy">
                            <span class="privacy-icon" id="privacy-icon">👁️</span>
                            <span style="font-size: 10px;" id="privacy-label">Hide</span>
                        </div>
                        <div class="privacy-toggle" onclick="showReversePanel()" title="Enable reverse copy from web consoles">
                            <span class="privacy-icon">🔄</span>
                            <span style="font-size: 10px;">Reverse</span>
                        </div>
                        | <span id="entry-count">0</span> items
                    </span>
                </div>
                <div 
                    class="notepad" 
                    id="notepad" 
                    contenteditable="true"
                    data-placeholder="Your clipboard history appears here..."
                ></div>
                
                <!-- Clipboard Management Actions -->
                <div class="clipboard-actions">
                    <button class="clipboard-action-btn" onclick="exportClipboard()" title="Export clipboard to text file">
                        📄 Export
                    </button>
                    <button class="clipboard-action-btn" onclick="clearClipboardHistory()" title="Clear all clipboard history">
                        🗑️ Clear
                    </button>
                    <button class="clipboard-action-btn" onclick="showClipboardStatus()" title="Show clipboard timing info">
                        ⏰ Status
                    </button>
                </div>
                
                <!-- Clipboard Timer Display -->
                <div class="clipboard-timer" id="clipboard-timer">
                    Clipboard auto-clear: Loading...
                </div>
            </div>

            <!-- Grid Section (BOTTOM - Fixed size for 9 cells) -->
            <div class="grid-section" id="grid-section">
                <div class="section-title">
                    Quick Paste Grid
                    <button class="collapse-btn" onclick="toggleGrid()" title="Collapse/Expand">
                        <span id="collapse-icon">▼</span>
                    </button>
                </div>
                <div class="paste-grid" id="paste-grid">
                    <!-- Grid cells will be generated here -->
                </div>
            </div>
        </div>

        <!-- Bottom Bar -->
        <div class="bottom-bar">
            <div class="paste-method">
                <label>Method:</label>
                <select class="method-select" id="paste-method">
                    <option value="keystrokes">Keystrokes</option>
                    <option value="clipboard">Clipboard</option>
                    <option value="powershell">PowerShell</option>
                </select>
            </div>
            <div class="speed-control">
                <label>Speed:</label>
                <input type="range" class="speed-slider" id="typing-speed" min="10" max="200" value="50">
                <span id="speed-value">50ms</span>
            </div>
            
            <!-- Developer Info Button -->
            <div class="dev-info-btn" onclick="showDevInfo()" title="Developer Info">i</div>
            
            <!-- Security Settings Button -->
            <div class="settings-btn" onclick="showSecuritySettings()" title="Security Settings">⚙</div>
        </div>
    </div>

    <!-- Toast notification -->
    <div class="toast" id="toast"></div>

    <!-- Peek Tooltip -->
    <div class="peek-tooltip" id="peek-tooltip"></div>

    <!-- Clipboard Warning -->
    <div class="clipboard-warning" id="clipboard-warning">
        <div class="clipboard-warning-title">
            ⚠️ Clipboard Auto-Clear Warning
        </div>
        <div class="clipboard-warning-message">
            Your clipboard history will be automatically cleared for security in:
        </div>
        <div class="clipboard-warning-countdown" id="warning-countdown">
            30 minutes
        </div>
        <div class="clipboard-warning-buttons">
            <button class="warning-btn warning-btn-primary" onclick="exportBeforeClear()">
                💾 Save & Clear
            </button>
            <button class="warning-btn warning-btn-secondary" onclick="postponeClipboardClear()">
                ⏰ Postpone
            </button>
            <button class="warning-btn warning-btn-secondary" onclick="dismissClipboardWarning()">
                ✕ Dismiss
            </button>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="export-modal" id="export-modal">
        <div class="export-content">
            <div class="export-title">
                📄 Export Clipboard History
            </div>
            <div class="export-preview" id="export-preview">
                Generating export preview...
            </div>
            <div class="export-buttons">
                <button class="export-btn export-btn-secondary" onclick="closeExportModal()">
                    Cancel
                </button>
                <button class="export-btn export-btn-primary" onclick="downloadExport()">
                    💾 Download
                </button>
            </div>
        </div>
    </div>

    <!-- Custom Dialog -->
    <div class="dialog-overlay" id="dialog-overlay">
        <div class="dialog-box">
            <div class="dialog-title" id="dialog-title">Enter Value</div>
            <input type="text" class="dialog-input" id="dialog-input" placeholder="Enter value...">
            <div class="dialog-buttons">
                <button class="dialog-btn dialog-btn-secondary" onclick="closeDialog(false)">Cancel</button>
                <button class="dialog-btn dialog-btn-primary" onclick="closeDialog(true)">OK</button>
            </div>
        </div>
    </div>

    <!-- Developer Info Dialog -->
    <div class="dev-info-dialog" id="dev-info-dialog">
        <div class="dev-info-content">
            <button class="dev-info-close" onclick="closeDevInfo()">×</button>
            <div class="dev-info-title">🎮 Anarchy Games</div>
            
            <div class="dev-info-item">
                <div class="dev-info-icon">👤</div>
                <span class="dev-info-link">Anarchy Games</span>
            </div>
            
            <div class="dev-info-item" onclick="openEmail()">
                <div class="dev-info-icon">📧</div>
                <a href="#" class="dev-info-link" onclick="openEmail(); return false;">support@anarchygames.net</a>
            </div>
            
            <div class="dev-info-item" onclick="openWebsite()">
                <div class="dev-info-icon">🌐</div>
                <a href="#" class="dev-info-link" onclick="openWebsite(); return false;">anarchygames.net</a>
            </div>
            
            <a href="#" class="donate-btn" onclick="openDonate(); return false;">
                💝 Support Development
            </a>
        </div>
    </div>

    <!-- Lock Screen -->
    <div class="lock-screen" id="lock-screen">
        <div class="lock-content">
            <div class="lock-icon">🔒</div>
            <div class="lock-title">Oblysk Locked</div>
            <div class="lock-subtitle" id="lock-subtitle">
                Enter your master password to continue
            </div>
            <input 
                type="password" 
                class="lock-input" 
                id="lock-password" 
                placeholder="Master password"
                autocomplete="current-password"
            >
            <button class="unlock-btn" id="unlock-btn" onclick="attemptUnlock()">
                🔓 Unlock
            </button>
            <div class="lock-error" id="lock-error">
                Incorrect password. Please try again.
            </div>
        </div>
    </div>

    <!-- Security Settings Dialog -->
    <div class="security-settings" id="security-settings">
        <div class="security-panel">
            <div class="security-panel-title">
                🔒 Security Settings
            </div>
            
            <div class="security-setting">
                <div class="setting-label">🔑 Master Password</div>
                <div class="setting-description">
                    Change your master password. This encrypts your stored data and locks the app.
                </div>
                <input 
                    type="password" 
                    class="setting-input" 
                    id="current-password" 
                    placeholder="Current password"
                    autocomplete="current-password"
                >
                <input 
                    type="password" 
                    class="setting-input" 
                    id="new-password" 
                    placeholder="New password"
                    autocomplete="new-password"
                    style="margin-top: 8px;"
                >
                <input 
                    type="password" 
                    class="setting-input" 
                    id="confirm-password" 
                    placeholder="Confirm new password"
                    autocomplete="new-password"
                    style="margin-top: 8px;"
                >
            </div>
            
            <div class="security-setting">
                <div class="setting-label">⏰ Auto-Lock Timeout</div>
                <div class="setting-description">
                    Automatically lock the app after inactivity. Range: 1-480 minutes (8 hours).
                </div>
                <input 
                    type="range" 
                    class="setting-range" 
                    id="lock-timeout-range" 
                    min="1" 
                    max="480" 
                    value="60"
                >
                <div class="range-value" id="timeout-value">60 minutes</div>
            </div>
            
            <div class="security-setting">
                <div class="setting-label">🔄 Session Info</div>
                <div class="setting-description">
                    Current session details and manual lock option.
                </div>
                <div style="display: flex; gap: 10px; margin-top: 8px;">
                    <button class="security-btn security-btn-secondary" onclick="lockAppNow()">
                        🔒 Lock Now
                    </button>
                    <span style="font-size: 12px; color: var(--text-secondary); display: flex; align-items: center;">
                        Session: <span id="session-time">Active</span>
                    </span>
                </div>
            </div>
            
            <div class="security-setting">
                <div class="setting-label">🛡️ Encryption Status</div>
                <div class="setting-description">
                    Your cell content is encrypted using your master password. Encrypted cells show a shield icon (🛡️).
                </div>
                <div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;" id="encryption-status">
                    Checking encryption status...
                </div>
            </div>
            
            <div class="security-setting">
                <div class="setting-label">👁️ Privacy & Masking</div>
                <div class="setting-description">
                    Control how sensitive content is displayed. When enabled, passwords and content are hidden with bullets (••••••).
                </div>
                <div style="display: flex; gap: 15px; margin-top: 12px; align-items: center;">
                    <label style="font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="mask-content-checkbox" style="margin-right: 5px;">
                        Mask cell content
                    </label>
                    <label style="font-size: 12px; cursor: pointer; display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="mask-clipboard-checkbox" style="margin-right: 5px;">
                        Mask clipboard history
                    </label>
                </div>
                <div style="margin-top: 8px;">
                    <label style="font-size: 12px; color: var(--text-secondary);">Peek duration:</label>
                    <input 
                        type="range" 
                        class="setting-range" 
                        id="peek-duration-range" 
                        min="1000" 
                        max="10000" 
                        step="500"
                        style="width: 120px; margin: 0 8px;"
                    >
                    <span id="peek-duration-value" style="font-size: 11px; color: var(--accent-primary);">3s</span>
                </div>
            </div>
            
            <div class="security-setting">
                <div class="setting-label">🧹 Clipboard Auto-Clear</div>
                <div class="setting-description">
                    Automatically clear clipboard history after 12 hours for security. Warning appears 30 minutes before clearing.
                </div>
                <div style="display: flex; gap: 10px; margin-top: 8px; align-items: center; flex-wrap: wrap;">
                    <button class="security-btn security-btn-secondary" onclick="exportClipboard()">
                        📄 Export Now
                    </button>
                    <button class="security-btn security-btn-secondary" onclick="clearClipboardHistory()">
                        🗑️ Clear Now
                    </button>
                    <button class="security-btn security-btn-secondary" onclick="showClipboardStatus()">
                        📊 Status
                    </button>
                </div>
                <div style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;" id="clipboard-status-display">
                    Loading clipboard status...
                </div>
            </div>
            
            <div class="security-buttons">
                <button class="security-btn security-btn-secondary" onclick="closeSecuritySettings()">
                    Cancel
                </button>
                <button class="security-btn security-btn-primary" onclick="saveSecuritySettings()">
                    💾 Save Changes
                </button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced global variables
        let ipcRenderer;
        let isElectron = false;
        let debugMode = false;
        
        // Startup management
        let startupSteps = [
            'Checking environment...',
            'Loading configuration...',
            'Initializing grid...',
            'Setting up event listeners...',
            'Configuring hotkeys...',
            'Starting security system...',
            'Finalizing startup...'
        ];
        let currentStartupStep = 0;

        // Enhanced Debug Logger
        class DebugLogger {
            constructor() {
                this.logs = [];
                this.maxLogs = 200;
                this.categories = new Set();
                this.levels = new Set();
            }
            
            log(level, category, message, data = null) {
                const entry = {
                    timestamp: new Date().toISOString(),
                    level,
                    category,
                    message,
                    data,
                    stack: level === 'error' ? new Error().stack : null,
                    id: Math.random().toString(36).substr(2, 9)
                };
                
                this.logs.unshift(entry);
                this.categories.add(category);
                this.levels.add(level);
                
                if (this.logs.length > this.maxLogs) {
                    this.logs.pop();
                }
                
                // Update debug panel if visible
                if (debugMode) {
                    this.updateDebugDisplay();
                }
                
                // Console output with colors
                const color = {
                    info: '#2196F3',
                    warn: '#FF9800', 
                    error: '#F44336',
                    success: '#4CAF50',
                    debug: '#9C27B0'
                }[level] || '#666';
                
                console.log(`%c[${category}] ${message}`, `color: ${color}`, data || '');
                
                // Send to main process if available
                if (isElectron && ipcRenderer) {
                    try {
                        ipcRenderer.send('renderer-log', entry);
                    } catch (e) {
                        // IPC might not be ready yet
                    }
                }
            }
            
            updateDebugDisplay() {
                const debugContent = document.getElementById('debug-content');
                if (!debugContent) return;
                
                const recent = this.logs.slice(0, 20);
                debugContent.innerHTML = recent.map(log => 
                    `<div class="debug-entry debug-${log.level}" data-id="${log.id}">
                        <span class="debug-time">${log.timestamp.split('T')[1].split('.')[0]}</span>
                        <span class="debug-category">[${log.category}]</span>
                        <span class="debug-message">${this.escapeHtml(log.message)}</span>
                        ${log.data ? `<pre class="debug-data">${this.escapeHtml(JSON.stringify(log.data, null, 2))}</pre>` : ''}
                    </div>`
                ).join('');
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = String(text);
                return div.innerHTML;
            }
            
            exportLogs() {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    isElectron,
                    debugMode,
                    totalLogs: this.logs.length,
                    categories: Array.from(this.categories),
                    levels: Array.from(this.levels),
                    logs: this.logs
                };
                
                const logText = `Oblysk Debug Export
Generated: ${exportData.timestamp}
Environment: ${isElectron ? 'Electron' : 'Browser'}
User Agent: ${exportData.userAgent}
Total Logs: ${exportData.totalLogs}

=== LOGS ===

${this.logs.map(log => 
`${log.timestamp} [${log.level.toUpperCase()}] [${log.category}] ${log.message}
${log.data ? 'Data: ' + JSON.stringify(log.data, null, 2) : ''}
${log.stack ? 'Stack: ' + log.stack : ''}
${'='.repeat(50)}`
).join('\n')}`;
                
                const blob = new Blob([logText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `oblysk-debug-${new Date().toISOString().split('T')[0]}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.log('success', 'debug', 'Debug logs exported');
                showToast('Debug logs exported to Downloads', 'success');
            }
            
            clear() {
                this.logs = [];
                this.categories.clear();
                this.levels.clear();
                this.updateDebugDisplay();
                this.log('info', 'debug', 'Debug logs cleared');
            }
            
            getStats() {
                const stats = {
                    total: this.logs.length,
                    byLevel: {},
                    byCategory: {},
                    errors: this.logs.filter(log => log.level === 'error').length,
                    recent: this.logs.slice(0, 5)
                };
                
                this.logs.forEach(log => {
                    stats.byLevel[log.level] = (stats.byLevel[log.level] || 0) + 1;
                    stats.byCategory[log.category] = (stats.byCategory[log.category] || 0) + 1;
                });
                
                return stats;
            }
        }

        const debugLogger = new DebugLogger();

        // Reverse Copy System
        class ReverseCapture {
            constructor() {
                this.isActive = false;
                this.lastCaptured = '';
                this.capturePatterns = [
                    /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+:/, // Linux prompt
                    /^C:\\/, // Windows path
                    /^\/[a-zA-Z0-9_/-]+\$/, // Unix path
                    /^\[.*\]/, // Bracketed output
                    /^(INFO|ERROR|DEBUG|WARN):/, // Log levels
                    /^.*\$\s/, // Shell prompt
                    /^.*#\s/, // Root prompt
                    /^(\d{1,3}\.){3}\d{1,3}/, // IP addresses
                    /^[a-fA-F0-9]{8,}/, // Hex strings (like hashes)
                ];
            }
            
            enable() {
                this.isActive = true;
                this.startClipboardMonitoring();
                debugLogger.log('success', 'reverse-copy', 'Reverse capture enabled');
                showToast('🔄 Reverse capture enabled - monitoring clipboard', 'success');
                updateReverseCopyUI();
            }
            
            disable() {
                this.isActive = false;
                debugLogger.log('info', 'reverse-copy', 'Reverse capture disabled');
                showToast('Reverse capture disabled', 'warning');
                updateReverseCopyUI();
            }
            
            toggle() {
                if (this.isActive) {
                    this.disable();
                } else {
                    this.enable();
                }
            }
            
            startClipboardMonitoring() {
                // This will work with the existing clipboard monitoring
                // We'll detect console-like content in the main clipboard handler
            }
            
            looksLikeConsoleOutput(text) {
                if (!text || text.length < 3) return false;
                
                const lines = text.split('\n');
                let consoleScore = 0;
                
                lines.forEach(line => {
                    const trimmed = line.trim();
                    if (this.capturePatterns.some(pattern => pattern.test(trimmed))) {
                        consoleScore++;
                    }
                });
                
                // If more than 30% of lines look like console output, consider it console content
                return (consoleScore / lines.length) > 0.3 || consoleScore >= 2;
            }
            
            async forceGrab() {
                try {
                    debugLogger.log('info', 'reverse-copy', 'Force grab initiated');
                    
                    // Method 1: Try to get selected text
                    const selection = window.getSelection();
                    if (selection.toString().trim()) {
                        const selectedText = selection.toString();
                        await this.handleCapture(selectedText, 'selection');
                        return true;
                    }
                    
                    // Method 2: Try clipboard after simulating copy
                    if (document.execCommand) {
                        document.execCommand('copy');
                        
                        setTimeout(async () => {
                            try {
                                const copied = await navigator.clipboard.readText();
                                if (copied.trim() && copied !== this.lastCaptured) {
                                    await this.handleCapture(copied, 'clipboard');
                                }
                            } catch (e) {
                                debugLogger.log('warn', 'reverse-copy', 'Clipboard read failed after copy command', { error: e.message });
                                showToast('Could not read clipboard - permission denied', 'error');
                            }
                        }, 100);
                    }
                    
                    // Method 3: Direct clipboard read
                    const clipboardContent = await navigator.clipboard.readText();
                    if (clipboardContent.trim() && clipboardContent !== this.lastCaptured) {
                        await this.handleCapture(clipboardContent, 'direct');
                        return true;
                    }
                    
                    showToast('No new content found to capture', 'warning');
                    return false;
                    
                } catch (error) {
                    debugLogger.log('error', 'reverse-copy', 'Force grab failed', { error: error.message });
                    showToast('Capture failed - try selecting text first', 'error');
                    return false;
                }
            }
            
            async handleCapture(text, source) {
                this.lastCaptured = text;
                
                // Add to clipboard history with special marking
                addToClipboardHistory(text, 'web-console', source);
                
                // Auto-send to local clipboard for immediate pasting
                if (isElectron && ipcRenderer) {
                    try {
                        ipcRenderer.send('set-local-clipboard', text);
                        debugLogger.log('success', 'reverse-copy', 'Content sent to local clipboard', { length: text.length, source });
                    } catch (e) {
                        debugLogger.log('warn', 'reverse-copy', 'Failed to set local clipboard', { error: e.message });
                    }
                }
                
                const preview = text.length > 50 ? text.substring(0, 50) + '...' : text;
                showToast(`📥 Captured (${source}): ${preview}`, 'success');
                
                debugLogger.log('success', 'reverse-copy', `Captured from ${source}`, { 
                    length: text.length, 
                    preview: text.substring(0, 30),
                    isConsoleOutput: this.looksLikeConsoleOutput(text)
                });
            }
            
            processClipboardChange(text) {
                if (!this.isActive || !text || text === this.lastCaptured) return false;
                
                if (this.looksLikeConsoleOutput(text)) {
                    this.handleCapture(text, 'auto-detect');
                    return true;
                }
                
                return false;
            }
        }

        const reverseCapture = new ReverseCapture();

        // Check if running in Electron
        try {
            if (window.require) {
                ipcRenderer = require('electron').ipcRenderer;
                isElectron = true;
                debugLogger.log('success', 'startup', 'Electron environment detected');
            }
        } catch (e) {
            debugLogger.log('info', 'startup', 'Browser environment detected');
        }

        // Configuration with enhanced defaults
        let config = {
            pasteMethod: 'keystrokes',
            typingSpeed: 50,
            cells: {},
            cellNames: {},
            clipboardHistory: [],
            autoCapture: true,
            gridCollapsed: false,
            debugMode: false,
            // Security settings
            masterPasswordHash: null,
            lockTimeout: 60, // minutes
            isLocked: false,
            sessionStartTime: null,
            // Privacy settings
            maskContent: true,
            maskClipboard: true,
            peekDuration: 3000, // milliseconds
            // Clipboard management
            clipboardMaxAge: 12 * 60 * 60 * 1000, // 12 hours in milliseconds
            clipboardWarningTime: 30 * 60 * 1000, // 30 minutes warning
            clipboardCreatedTime: null,
            clipboardWarningShown: false,
            // Reverse copy settings
            reverseCopyEnabled: false
        };

        let lastClipboardContent = '';
        let isManualEdit = false;
        let lockTimer = null;
        let sessionTimer = null;
        let revealTimers = new Map();
        let clipboardTimer = null;
        let clipboardWarningTimer = null;
        let clipboardCountdownInterval = null;

        // Startup Management
        function updateStartupProgress(step) {
            const progressElement = document.getElementById('startup-progress');
            if (progressElement && step < startupSteps.length) {
                progressElement.textContent = startupSteps[step];
                currentStartupStep = step;
                debugLogger.log('info', 'startup', `Step ${step + 1}/${startupSteps.length}: ${startupSteps[step]}`);
            }
        }

        function hideStartupOverlay() {
            const overlay = document.getElementById('startup-overlay');
            overlay.classList.add('hidden');
            
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 500);
            
            debugLogger.log('success', 'startup', 'Startup overlay hidden');
        }

        // Enhanced startup sequence
        async function initializeApp() {
            debugLogger.log('info', 'startup', 'Application initialization started');
            
            try {
                updateStartupProgress(0); // Checking environment
                await delay(200);
                
                updateStartupProgress(1); // Loading configuration
                loadConfig();
                await delay(300);
                
                updateStartupProgress(2); // Initializing grid
                initializeGrid();
                await delay(200);
                
                updateStartupProgress(3); // Setting up event listeners
                setupEventListeners();
                await delay(200);
                
                updateStartupProgress(4); // Configuring hotkeys
                setupGlobalHotkeys();
                await delay(300);
                
                updateStartupProgress(5); // Starting security system
                setupSecuritySystem();
                await delay(200);
                
                updateStartupProgress(6); // Finalizing startup
                finalizeStartup();
                await delay(300);
                
                hideStartupOverlay();
                
                // Show ready state
                setStatus('success', 'Ready');
                showToast('🚀 Oblysk ready for action!', 'success');
                debugLogger.log('success', 'startup', 'Application initialization completed successfully');
                
            } catch (error) {
                debugLogger.log('error', 'startup', 'Application initialization failed', { error: error.message, stack: error.stack });
                setStatus('error', 'Initialization failed');
                showToast('❌ Startup failed - check debug panel', 'error');
                
                // Auto-enable debug mode on startup failure
                setTimeout(() => {
                    if (!debugMode) {
                        toggleDebugMode();
                    }
                }, 1000);
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function finalizeStartup() {
            // Set up any final configuration
            updateAutoCaptureUI();
            updatePrivacyUI();
            
            // Update display counters
            document.getElementById('entry-count').textContent = config.clipboardHistory.length;
            
            // Set initial method selection
            document.getElementById('paste-method').value = config.pasteMethod;
            document.getElementById('typing-speed').value = config.typingSpeed;
            document.getElementById('speed-value').textContent = `${config.typingSpeed}ms`;
            
            debugLogger.log('info', 'startup', 'Finalization completed');
        }

        // Debug functions
        function toggleDebugMode() {
            debugMode = !debugMode;
            const panel = document.getElementById('debug-panel');
            
            if (debugMode) {
                panel.style.display = 'block';
                config.debugMode = true;
                showToast('🔧 Debug mode enabled', 'warning');
                debugLogger.log('info', 'debug', 'Debug mode enabled');
                debugLogger.updateDebugDisplay();
            } else {
                panel.style.display = 'none';
                config.debugMode = false;
                showToast('Debug mode disabled', 'success');
                debugLogger.log('info', 'debug', 'Debug mode disabled');
            }
            
            saveConfig();
        }

        function clearDebugLogs() {
            debugLogger.clear();
            showToast('Debug logs cleared', 'success');
        }

        function setStatus(type, message) {
            const indicator = document.getElementById('status');
            indicator.className = `status-indicator ${type}`;
            
            debugLogger.log('info', 'status', `Status changed to ${type}: ${message}`);
        }

        // Initialize with enhanced error handling
        document.addEventListener('DOMContentLoaded', () => {
            debugLogger.log('info', 'startup', '🚀 DOM Content Loaded - Starting Oblysk...');
            setStatus('working', 'Initializing...');
            
            // Start the enhanced initialization sequence
            setTimeout(() => {
                initializeApp();
            }, 500); // Small delay to ensure DOM is fully ready
        });

        // IPC Event Handlers for main process communication
        if (isElectron && ipcRenderer) {
            ipcRenderer.on('paste-cell', async (event, cellNumber) => {
                debugLogger.log('info', 'ipc', `Received paste-cell event: ${cellNumber}`);
                await pasteCell(cellNumber);
            });
            
            ipcRenderer.on('copy-to-notepad', async () => {
                debugLogger.log('info', 'ipc', 'Received copy-to-notepad event');
                await captureClipboard();
            });
            
            ipcRenderer.on('clipboard-changed', (event, text) => {
                debugLogger.log('debug', 'clipboard', `Clipboard changed: ${text.length} chars`);
                
                // Check if reverse copy should handle this
                if (!reverseCapture.processClipboardChange(text)) {
                    // Normal clipboard processing
                    if (config.autoCapture && !isManualEdit && text !== lastClipboardContent) {
                        lastClipboardContent = text;
                        addToClipboardHistory(text, 'text');
                    }
                }
            });
            
            ipcRenderer.on('paste-on-deck', async () => {
                debugLogger.log('info', 'ipc', 'Received paste-on-deck event');
                await pasteOnDeck();
            });
            
            ipcRenderer.on('reverse-copy', async () => {
                debugLogger.log('info', 'ipc', 'Received reverse-copy event');
                await reverseCapture.forceGrab();
            });
            
            ipcRenderer.on('hotkey-registration-complete', (event, data) => {
                debugLogger.log('info', 'hotkeys', 'Hotkey registration completed', data);
                
                if (data.failed && data.failed.length > 0) {
                    showToast(`⚠️ ${data.failed.length} hotkeys failed to register`, 'warning');
                } else {
                    showToast(`✅ All ${data.registered} hotkeys registered`, 'success');
                }
            });
            
            ipcRenderer.on('main-process-log', (event, logEntry) => {
                // Display main process logs in debug panel if needed
                if (debugMode) {
                    debugLogger.log(logEntry.level, `main-${logEntry.category}`, logEntry.message, logEntry.data);
                }
            });
        }

        // Setup security system
        function setupSecuritySystem() {
            debugLogger.log('info', 'security', 'Setting up security system');
            
            if (isFirstRun()) {
                debugLogger.log('info', 'security', 'First run detected - will prompt for master password');
                setTimeout(() => {
                    setupMasterPassword();
                }, 2000);
            } else {
                debugLogger.log('info', 'security', 'Existing installation - starting locked');
                config.isLocked = true;
                setTimeout(() => {
                    lockApp();
                }, 1000);
            }

            setupActivityDetection();
            initializeClipboardManagement();
        }

        // Setup activity detection
        function setupActivityDetection() {
            const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
            
            events.forEach(event => {
                document.addEventListener(event, resetLockTimer, true);
            });
            
            debugLogger.log('info', 'security', 'Activity detection enabled');
        }

        // Initialize the 3x3 grid with improved click handling
        function initializeGrid() {
            const grid = document.getElementById('paste-grid');
            
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.index = i + 1;
                
                const nameDisplay = document.createElement('div');
                nameDisplay.className = 'cell-name-display empty';
                nameDisplay.textContent = 'Click to name';
                nameDisplay.dataset.cell = i + 1;
                
                // Improved click handling with better timing
                let clickCount = 0;
                let clickTimer = null;
                
                cell.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    clickCount++;
                    
                    if (clickCount === 1) {
                        clickTimer = setTimeout(() => {
                            // Single click - edit name
                            debugLogger.log('info', 'grid', `Single click on cell ${i + 1}`);
                            editCellName(i + 1);
                            clickCount = 0;
                        }, 250); // Reduced from 300ms for better responsiveness
                    } else if (clickCount === 2) {
                        // Double click - edit content
                        clearTimeout(clickTimer);
                        debugLogger.log('info', 'grid', `Double click on cell ${i + 1}`);
                        editCellContent(i + 1);
                        clickCount = 0;
                    }
                });
                
                cell.appendChild(nameDisplay);
                grid.appendChild(cell);
            }
            
            debugLogger.log('success', 'grid', 'Grid initialized with improved click detection');
        }

        // Custom dialog functions
        let dialogResolve = null;

        function showDialog(title, placeholder = '', defaultValue = '') {
            return new Promise((resolve) => {
                dialogResolve = resolve;
                
                document.getElementById('dialog-title').textContent = title;
                document.getElementById('dialog-input').placeholder = placeholder;
                document.getElementById('dialog-input').value = defaultValue;
                document.getElementById('dialog-overlay').style.display = 'flex';
                
                setTimeout(() => {
                    const input = document.getElementById('dialog-input');
                    input.focus();
                    input.select();
                }, 100);
                
                debugLogger.log('info', 'dialog', `Dialog shown: ${title}`);
            });
        }

        function closeDialog(confirmed) {
            const overlay = document.getElementById('dialog-overlay');
            const input = document.getElementById('dialog-input');
            
            overlay.style.display = 'none';
            
            if (dialogResolve) {
                const result = confirmed ? input.value : null;
                debugLogger.log('info', 'dialog', `Dialog closed: ${confirmed ? 'confirmed' : 'cancelled'}`, { result });
                dialogResolve(result);
                dialogResolve = null;
            }
        }

        // Enhanced event listeners with better state management
        function setupEventListeners() {
            debugLogger.log('info', 'events', 'Setting up event listeners');
            
            // Paste method change with state reset
            document.getElementById('paste-method').addEventListener('change', (e) => {
                const oldMethod = config.pasteMethod;
                config.pasteMethod = e.target.value;
                
                // Reset any method-specific state
                if (oldMethod !== e.target.value) {
                    debugLogger.log('info', 'settings', `Paste method changed: ${oldMethod} → ${e.target.value}`);
                    
                    // Clear any cached state that might interfere
                    if (oldMethod === 'powershell') {
                        debugLogger.log('info', 'settings', 'Clearing PowerShell-specific state');
                    }
                }
                
                saveConfig();
                showToast(`Paste method: ${e.target.value}`, 'success');
            });
            
            // Speed slider
            const speedSlider = document.getElementById('typing-speed');
            const speedValue = document.getElementById('speed-value');
            
            speedSlider.addEventListener('input', (e) => {
                config.typingSpeed = parseInt(e.target.value);
                speedValue.textContent = `${config.typingSpeed}ms`;
                saveConfig();
                debugLogger.log('debug', 'settings', `Typing speed changed to ${config.typingSpeed}ms`);
            });
            
            // Security timeout range slider
            const timeoutSlider = document.getElementById('lock-timeout-range');
            if (timeoutSlider) {
                timeoutSlider.addEventListener('input', updateTimeoutDisplay);
            }
            
            // Privacy settings
            const peekDurationSlider = document.getElementById('peek-duration-range');
            if (peekDurationSlider) {
                peekDurationSlider.addEventListener('input', updatePeekDurationDisplay);
            }
            
            // Global keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Debug toggle
                if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'd') {
                    e.preventDefault();
                    toggleDebugMode();
                }
                
                // Reverse copy manual trigger
                if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'r') {
                    e.preventDefault();
                    reverseCapture.forceGrab();
                }
                
                // Browser mode hotkeys (when not in Electron)
                if (!isElectron && e.ctrlKey && e.altKey) {
                    if (e.key >= '1' && e.key <= '9') {
                        e.preventDefault();
                        pasteCell(parseInt(e.key));
                    } else if (e.key.toLowerCase() === 'v') {
                        e.preventDefault();
                        pasteOnDeck();
                    } else if (e.code && e.code.startsWith('Numpad') && e.code !== 'NumpadEnter') {
                        const numpadNumber = e.code.replace('Numpad', '');
                        if (numpadNumber >= '1' && numpadNumber <= '9') {
                            e.preventDefault();
                            pasteCell(parseInt(numpadNumber));
                        }
                    }
                }
            });
            
            // Dialog keyboard handling
            document.addEventListener('keydown', (e) => {
                const overlay = document.getElementById('dialog-overlay');
                const devInfoDialog = document.getElementById('dev-info-dialog');
                const securitySettings = document.getElementById('security-settings');
                const lockScreen = document.getElementById('lock-screen');
                
                if (lockScreen.style.display === 'flex') {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        attemptUnlock();
                    }
                    return;
                }
                
                if (overlay.style.display === 'flex') {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        closeDialog(true);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        closeDialog(false);
                    }
                }
                
                if (devInfoDialog.style.display === 'flex' && e.key === 'Escape') {
                    e.preventDefault();
                    closeDevInfo();
                }
                
                if (securitySettings.style.display === 'flex' && e.key === 'Escape') {
                    e.preventDefault();
                    closeSecuritySettings();
                }
            });
            
            debugLogger.log('success', 'events', 'Event listeners configured');
        }

        // Enhanced hotkey setup
        function setupGlobalHotkeys() {
            if (isElectron && ipcRenderer) {
                debugLogger.log('info', 'hotkeys', 'Setting up IPC listeners for Electron hotkeys');
                // IPC listeners are already set up above
            } else {
                debugLogger.log('info', 'hotkeys', 'Browser mode - limited hotkey functionality');
            }
        }

        // Reverse Copy UI Functions
        function showReversePanel() {
            const panel = document.getElementById('reverse-copy-panel');
            panel.classList.add('active');
            debugLogger.log('info', 'reverse-copy', 'Reverse copy panel shown');
        }

        function closeReversePanel() {
            const panel = document.getElementById('reverse-copy-panel');
            panel.classList.remove('active');
            debugLogger.log('info', 'reverse-copy', 'Reverse copy panel hidden');
        }

        function toggleReverseCapture() {
            reverseCapture.toggle();
        }

        function updateReverseCopyUI() {
            const toggleText = document.getElementById('reverse-copy-toggle-text');
            const status = document.getElementById('reverse-copy-status');
            
            if (reverseCapture.isActive) {
                toggleText.textContent = 'Disable';
                status.textContent = 'Active - monitoring clipboard for console output. Press Ctrl+Alt+R to force grab.';
                status.style.color = 'var(--success)';
            } else {
                toggleText.textContent = 'Enable';
                status.textContent = 'Inactive - enable to capture text from web consoles.';
                status.style.color = 'var(--text-secondary)';
            }
        }

        function testReverseCapture() {
            const testText = `user@hostname:~$ ls -la
total 42
drwxr-xr-x 2 user user 4096 Jan 1 12:00 .
drwxr-xr-x 3 user user 4096 Jan 1 11:59 ..
-rw-r--r-- 1 user user  220 Jan 1 12:00 .bash_logout`;
            
            reverseCapture.handleCapture(testText, 'test');
            showToast('📝 Test capture completed - check clipboard history', 'success');
        }

        // Edit cell name (single click)
        async function editCellName(cellNumber) {
            if (config.isLocked) {
                showToast('App is locked', 'error');
                return;
            }
            
            debugLogger.log('info', 'cell', `Editing name for cell ${cellNumber}`);
            
            try {
                const currentName = config.cellNames[cellNumber] || '';
                const newName = await showDialog(
                    `Name for Cell ${cellNumber}`,
                    'Enter a display name...',
                    currentName
                );
                
                if (newName !== null) {
                    config.cellNames[cellNumber] = newName.trim();
                    saveConfig();
                    updateCellDisplay(cellNumber);
                    
                    if (newName.trim()) {
                        showToast(`Cell ${cellNumber} named: ${newName.trim()}`, 'success');
                        debugLogger.log('success', 'cell', `Cell ${cellNumber} named: ${newName.trim()}`);
                    } else {
                        showToast(`Cell ${cellNumber} name cleared`, 'warning');
                        debugLogger.log('info', 'cell', `Cell ${cellNumber} name cleared`);
                    }
                }
            } catch (error) {
                debugLogger.log('error', 'cell', `Failed to edit cell ${cellNumber} name`, { error: error.message });
                showToast(`Error editing cell name: ${error.message}`, 'error');
            }
        }

        // Edit cell content (double click)
        async function editCellContent(cellNumber) {
            if (config.isLocked) {
                showToast('App is locked', 'error');
                return;
            }
            
            debugLogger.log('info', 'cell', `Editing content for cell ${cellNumber}`);
            
            try {
                const cellName = config.cellNames[cellNumber] || `Cell ${cellNumber}`;
                const currentContent = getDecryptedCellContent(cellNumber) || '';
                
                const newContent = await showDialog(
                    `Content for "${cellName}"`,
                    'Enter password or content (will be encrypted)...',
                    currentContent
                );
                
                if (newContent !== null) {
                    setEncryptedCellContent(cellNumber, newContent);
                    saveConfig();
                    updateCellDisplay(cellNumber);
                    
                    if (newContent.trim()) {
                        const isEncrypted = getCurrentEncryptionKey() ? ' (encrypted)' : '';
                        showToast(`Content set for ${cellName}${isEncrypted}`, 'success');
                        debugLogger.log('success', 'cell', `Content set for cell ${cellNumber}`, { length: newContent.length, encrypted: !!getCurrentEncryptionKey() });
                    } else {
                        showToast(`Content cleared for ${cellName}`, 'warning');
                        debugLogger.log('info', 'cell', `Content cleared for cell ${cellNumber}`);
                    }
                }
            } catch (error) {
                debugLogger.log('error', 'cell', `Failed to edit cell ${cellNumber} content`, { error: error.message });
                showToast(`Error editing cell content: ${error.message}`, 'error');
            }
        }

        // Update cell display
        function updateCellDisplay(cellNumber) {
            const nameDisplay = document.querySelector(`[data-cell="${cellNumber}"].cell-name-display`);
            const cell = nameDisplay?.parentElement;
            
            if (!nameDisplay || !cell) return;
            
            const cellName = config.cellNames[cellNumber];
            const hasContent = config.cells[cellNumber] && config.cells[cellNumber].trim();
            const isEncrypted = hasContent && config.cells[cellNumber].startsWith('ENC:');
            
            if (cellName && cellName.trim()) {
                nameDisplay.textContent = cellName.trim();
                nameDisplay.classList.remove('empty');
            } else {
                nameDisplay.textContent = 'Click to name';
                nameDisplay.classList.add('empty');
            }
            
            if (hasContent) {
                cell.classList.add('cell-has-content');
                
                if (isEncrypted) {
                    cell.classList.add('cell-encrypted');
                } else {
                    cell.classList.remove('cell-encrypted');
                }
                
                const content = getDecryptedCellContent(cellNumber);
                if (content && content !== '[CORRUPTED DATA]') {
                    const preview = config.maskContent ? maskText(content, true) : content.substring(0, 50) + (content.length > 50 ? '...' : '');
                    cell.title = `Content: ${preview}${config.maskContent ? ' (Click to edit/view)' : ''}`;
                } else if (content === '[CORRUPTED DATA]') {
                    cell.title = 'Content: [CORRUPTED DATA] - Re-enter content to fix';
                }
            } else {
                cell.classList.remove('cell-has-content');
                cell.classList.remove('cell-encrypted');
                cell.title = 'Empty - Double-click to add content';
            }
        }

        // Enhanced paste function with better error handling
        async function pasteCell(cellNumber) {
            if (config.isLocked) {
                showToast('App is locked', 'error');
                return;
            }
            
            const startTime = Date.now();
            const content = getDecryptedCellContent(cellNumber);
            const cellName = config.cellNames[cellNumber];
            
            debugLogger.log('info', 'paste', `Starting paste for cell ${cellNumber}`, { hasContent: !!content, cellName, method: config.pasteMethod });
            
            if (!content || content.trim() === '') {
                const displayName = cellName || `Cell ${cellNumber}`;
                showToast(`${displayName} is empty`, 'error');
                setStatus('error', 'Cell empty');
                debugLogger.log('warn', 'paste', `Paste failed - cell ${cellNumber} is empty`);
                return;
            }
            
            if (content === '[CORRUPTED DATA]') {
                const displayName = cellName || `Cell ${cellNumber}`;
                showToast(`${displayName} contains corrupted data`, 'error');
                setStatus('error', 'Corrupted data');
                debugLogger.log('error', 'paste', `Paste failed - cell ${cellNumber} has corrupted data`);
                return;
            }
            
            const displayName = cellName || `Cell ${cellNumber}`;
            setStatus('working', `Pasting ${displayName}...`);
            showToast(`Pasting ${displayName}...`, 'warning');
            
            try {
                if (!isElectron) {
                    // Browser mode - copy to clipboard
                    await navigator.clipboard.writeText(content);
                    showToast(`Cell ${cellNumber} copied to clipboard - press Ctrl+V`, 'success');
                    setStatus('success', 'Copied to clipboard');
                    debugLogger.log('success', 'paste', `Cell ${cellNumber} copied to clipboard (browser mode)`);
                    return;
                }
                
                // Electron mode - use IPC
                let result;
                const requestData = {
                    text: content,
                    delay: config.typingSpeed
                };
                
                switch (config.pasteMethod) {
                    case 'keystrokes':
                        result = await ipcRenderer.invoke('simulate-keystrokes', requestData);
                        break;
                    case 'clipboard':
                        result = await ipcRenderer.invoke('paste-via-clipboard', content);
                        break;
                    case 'powershell':
                        result = await ipcRenderer.invoke('paste-powershell', content);
                        break;
                    default:
                        throw new Error(`Unknown paste method: ${config.pasteMethod}`);
                }
                
                const duration = Date.now() - startTime;
                debugLogger.log('info', 'paste', `Paste operation completed`, { 
                    result, 
                    duration, 
                    method: config.pasteMethod,
                    cellNumber,
                    contentLength: content.length 
                });
                
                if (result.success) {
                    showToast(result.message || `${displayName} pasted successfully`, 'success');
                    setStatus('success', 'Paste successful');
                } else {
                    throw new Error(result.error || 'Paste failed');
                }
                
            } catch (error) {
                const duration = Date.now() - startTime;
                debugLogger.log('error', 'paste', `Paste failed for cell ${cellNumber}`, { 
                    error: error.message, 
                    duration,
                    method: config.pasteMethod 
                });
                setStatus('error', 'Paste failed');
                
                try {
                    await navigator.clipboard.writeText(content);
                    showToast(`Paste failed - copied to clipboard instead`, 'warning');
                } catch (clipboardError) {
                    showToast(`Paste and clipboard failed: ${error.message}`, 'error');
                }
            }
        }

        // Enhanced paste function for on-deck clipboard
        async function pasteOnDeck() {
            if (config.isLocked) {
                showToast('App is locked', 'error');
                return;
            }
            
            if (!config.clipboardHistory || config.clipboardHistory.length === 0) {
                showToast('No clipboard history available', 'error');
                setStatus('error', 'No clipboard history');
                debugLogger.log('warn', 'paste', 'On-deck paste failed - no clipboard history');
                return;
            }
            
            const onDeckItem = config.clipboardHistory[0];
            const content = onDeckItem.content;
            
            debugLogger.log('info', 'paste', 'Starting on-deck paste', { length: content.length, timestamp: onDeckItem.timestamp });
            
            if (!content || content.trim() === '') {
                showToast('On-deck item is empty', 'error');
                setStatus('error', 'On-deck empty');
                debugLogger.log('warn', 'paste', 'On-deck paste failed - content is empty');
                return;
            }
            
            setStatus('working', 'Pasting on-deck...');
            showToast('Pasting on-deck item...', 'warning');
            
            try {
                if (!isElectron) {
                    await navigator.clipboard.writeText(content);
                    showToast('On-deck item copied to clipboard - press Ctrl+V', 'success');
                    setStatus('success', 'Copied to clipboard');
                    debugLogger.log('success', 'paste', 'On-deck item copied to clipboard (browser mode)');
                    return;
                }
                
                let result;
                switch (config.pasteMethod) {
                    case 'keystrokes':
                        result = await ipcRenderer.invoke('simulate-keystrokes', {
                            text: content,
                            delay: config.typingSpeed
                        });
                        break;
                    case 'clipboard':
                        result = await ipcRenderer.invoke('paste-via-clipboard', content);
                        break;
                    case 'powershell':
                        result = await ipcRenderer.invoke('paste-powershell', content);
                        break;
                    default:
                        throw new Error(`Unknown paste method: ${config.pasteMethod}`);
                }
                
                debugLogger.log('info', 'paste', 'On-deck paste completed', { result });
                
                if (result.success) {
                    showToast(result.message || 'On-deck item pasted successfully', 'success');
                    setStatus('success', 'On-deck paste successful');
                } else {
                    throw new Error(result.error || 'On-deck paste failed');
                }
                
            } catch (error) {
                debugLogger.log('error', 'paste', 'On-deck paste failed', { error: error.message });
                setStatus('error', 'On-deck paste failed');
                
                try {
                    await navigator.clipboard.writeText(content);
                    showToast('On-deck paste failed - copied to clipboard instead', 'warning');
                } catch (clipboardError) {
                    showToast(`On-deck paste and clipboard failed: ${error.message}`, 'error');
                }
            }
        }

        // Enhanced clipboard history management
        function addToClipboardHistory(content, type = 'text', source = 'auto') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = { 
                content, 
                type, 
                timestamp, 
                source,
                id: Math.random().toString(36).substr(2, 9)
            };
            
            config.clipboardHistory.unshift(entry);
            
            if (!config.clipboardCreatedTime) {
                config.clipboardCreatedTime = Date.now();
                config.clipboardWarningShown = false;
                startClipboardTimers();
            }
            
            if (config.clipboardHistory.length > 50) {
                const removed = config.clipboardHistory.pop();
                debugLogger.log('debug', 'clipboard', 'Removed oldest clipboard entry', { removedId: removed.id });
            }
            
            updateNotepadDisplay();
            updateClipboardTimer();
            saveConfig();
            
            // Visual feedback
            const indicator = document.getElementById('clipboard-status');
            indicator.style.color = '#10b981';
            setTimeout(() => {
                indicator.style.color = 'var(--success)';
            }, 300);
            
            debugLogger.log('info', 'clipboard', 'Added to clipboard history', { 
                type, 
                source, 
                length: content.length, 
                total: config.clipboardHistory.length 
            });
        }

        function updateNotepadDisplay() {
            const notepad = document.getElementById('notepad');
            if (isManualEdit) return;
            
            let html = '';
            for (let i = 0; i < config.clipboardHistory.length; i++) {
                const entry = config.clipboardHistory[i];
                const isOnDeck = i === 0;
                const entryId = `clipboard-entry-${i}`;
                
                // Special styling for reverse copy entries
                const isReverseCopy = entry.source && entry.source.includes('selection') || entry.source === 'web-console';
                const sourceIcon = isReverseCopy ? '🔄' : '📋';
                
                html += `<div class="clipboard-entry ${isOnDeck ? 'on-deck' : ''}" id="${entryId}">
                    <div style="font-size: 10px; color: var(--text-secondary); margin-bottom: 4px;">
                        ${sourceIcon} ${entry.timestamp}${isOnDeck ? ' • Press Ctrl+Alt+V to paste' : ''}
                        ${isReverseCopy ? ' • From web console' : ''}
                        ${config.maskContent ? ' • Click to peek' : ''}
                    </div>
                    <div class="clipboard-content" style="word-wrap: break-word; white-space: pre-wrap;">`;
                
                if (entry.type === 'image') {
                    if (config.maskContent) {
                        html += `<div class="masked-content" onclick="revealImageContent('${entryId}')">📷 Image (Click to view)</div>`;
                    } else {
                        html += `<img src="${entry.content}" style="max-width: 100%; max-height: 200px; border-radius: 4px;">`;
                    }
                } else {
                    if (config.maskContent) {
                        const maskedText = maskText(entry.content);
                        html += `<span class="masked-content" 
                                    onclick="revealClipboardEntry(${i})"
                                    onmouseover="showPeekTooltip(event, atob('${btoa(entry.content)}'))"
                                    onmouseout="hidePeekTooltip()"
                                >${maskedText}</span>`;
                    } else {
                        html += escapeHtml(entry.content);
                    }
                }
                
                html += `</div></div>`;
            }
            
            notepad.innerHTML = html;
            document.getElementById('entry-count').textContent = config.clipboardHistory.length;
        }

        function revealClipboardEntry(index) {
            if (!config.maskContent) return;
            
            const entry = config.clipboardHistory[index];
            if (!entry) return;
            
            const entryElement = document.getElementById(`clipboard-entry-${index}`);
            const contentElement = entryElement?.querySelector('.clipboard-content');
            
            if (contentElement) {
                revealContentTemporarily(contentElement, entry.content, `clipboard-${index}`);
            }
        }

        // [Continue with all the other functions from the original code...]
        // Security functions, clipboard management, etc. would follow here
        // I'll include the key ones that were mentioned as having issues:

        async function captureClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                if (text) {
                    addToClipboardHistory(text, 'text', 'manual');
                    showToast('Captured from clipboard', 'success');
                    debugLogger.log('success', 'clipboard', 'Manual clipboard capture', { length: text.length });
                }
            } catch (err) {
                debugLogger.log('error', 'clipboard', 'Failed to read clipboard', { error: err.message });
                showToast('Failed to read clipboard', 'error');
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function toggleGrid() {
            const gridSection = document.getElementById('grid-section');
            const icon = document.getElementById('collapse-icon');
            
            gridSection.classList.toggle('collapsed');
            
            if (gridSection.classList.contains('collapsed')) {
                icon.textContent = '▲';
            } else {
                icon.textContent = '▼';
            }
            
            config.gridCollapsed = gridSection.classList.contains('collapsed');
            saveConfig();
            debugLogger.log('info', 'ui', `Grid ${gridSection.classList.contains('collapsed') ? 'collapsed' : 'expanded'}`);
        }

        function toggleAutoCapture() {
            config.autoCapture = !config.autoCapture;
            updateAutoCaptureUI();
            saveConfig();
            
            debugLogger.log('info', 'settings', `Auto-capture ${config.autoCapture ? 'enabled' : 'disabled'}`);
            
            if (config.autoCapture) {
                showToast('Auto-capture enabled', 'success');
            } else {
                showToast('Auto-capture disabled - use Ctrl+Alt+C to capture manually', 'warning');
            }
        }

        function updateAutoCaptureUI() {
            const toggleSwitch = document.getElementById('auto-toggle');
            const toggleLabel = document.getElementById('auto-label');
            
            if (config.autoCapture) {
                toggleSwitch.classList.add('active');
                toggleLabel.textContent = 'Auto';
            } else {
                toggleSwitch.classList.remove('active');
                toggleLabel.textContent = 'Manual';
            }
        }

        function loadConfig() {
            try {
                const saved = localStorage.getItem('oblysk-config');
                if (saved) {
                    const parsedConfig = JSON.parse(saved);
                    config = { ...config, ...parsedConfig };
                    debugLogger.log('success', 'config', 'Configuration loaded from localStorage');
                } else {
                    debugLogger.log('info', 'config', 'No saved configuration found, using defaults');
                }
                
                // Apply loaded configuration
                document.getElementById('paste-method').value = config.pasteMethod;
                document.getElementById('typing-speed').value = config.typingSpeed;
                document.getElementById('speed-value').textContent = `${config.typingSpeed}ms`;
                
                for (let i = 1; i <= 9; i++) {
                    updateCellDisplay(i);
                }
                
                const savedHistory = localStorage.getItem('oblysk-clipboard-history');
                if (savedHistory) {
                    config.clipboardHistory = JSON.parse(savedHistory);
                    updateNotepadDisplay();
                    debugLogger.log('info', 'config', `Loaded ${config.clipboardHistory.length} clipboard history items`);
                }
                
                updateAutoCaptureUI();
                updatePrivacyUI();
                
                if (config.gridCollapsed) {
                    document.getElementById('grid-section').classList.add('collapsed');
                    document.getElementById('collapse-icon').textContent = '▲';
                }
                
                // Restore debug mode if it was enabled
                if (config.debugMode) {
                    debugMode = true;
                    document.getElementById('debug-panel').style.display = 'block';
                }
                
            } catch (error) {
                debugLogger.log('error', 'config', 'Failed to load configuration', { error: error.message });
                showToast('Failed to load saved configuration', 'warning');
            }
        }

        function saveConfig() {
            try {
                localStorage.setItem('oblysk-config', JSON.stringify(config));
                localStorage.setItem('oblysk-clipboard-history', JSON.stringify(config.clipboardHistory));
                debugLogger.log('debug', 'config', 'Configuration saved to localStorage');
            } catch (error) {
                debugLogger.log('error', 'config', 'Failed to save configuration', { error: error.message });
                showToast('Failed to save configuration', 'error');
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
            
            debugLogger.log('info', 'ui', `Toast shown: ${message}`, { type });
        }

        function minimizeApp() {
            if (ipcRenderer) {
                ipcRenderer.send('minimize-window');
                debugLogger.log('info', 'window', 'Minimize requested');
            }
        }

        function closeApp() {
            if (ipcRenderer) {
                ipcRenderer.send('close-app');
                debugLogger.log('info', 'window', 'Close requested');
            }
        }

        // Developer info functions
        function showDevInfo() {
            document.getElementById('dev-info-dialog').style.display = 'flex';
            debugLogger.log('info', 'ui', 'Developer info dialog shown');
        }

        function closeDevInfo() {
            document.getElementById('dev-info-dialog').style.display = 'none';
            debugLogger.log('info', 'ui', 'Developer info dialog closed');
        }

        function openEmail() {
            if (isElectron && require) {
                require('electron').shell.openExternal('mailto:support@anarchygames.net');
            } else {
                window.open('mailto:support@anarchygames.net', '_blank');
            }
            showToast('Opening email client...', 'success');
            debugLogger.log('info', 'external', 'Email link opened');
        }

        function openWebsite() {
            if (isElectron && require) {
                require('electron').shell.openExternal('https://anarchygames.net');
            } else {
                window.open('https://anarchygames.net', '_blank');
            }
            showToast('Opening website...', 'success');
            debugLogger.log('info', 'external', 'Website link opened');
        }

        function openDonate() {
            if (isElectron && require) {
                require('electron').shell.openExternal('https://anarchygames.net/donate');
            } else {
                window.open('https://anarchygames.net/donate', '_blank');
            }
            showToast('Thank you for supporting development! 💝', 'success');
            debugLogger.log('info', 'external', 'Donate link opened');
        }

        // Security System Functions (simplified for space - include all from original)
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash.toString();
        }

        function encryptText(text, key) {
            if (!text || !key) return text;
            
            let result = '';
            const keyHash = simpleHash(key);
            
            for (let i = 0; i < text.length; i++) {
                const textChar = text.charCodeAt(i);
                const keyChar = keyHash.charCodeAt(i % keyHash.length);
                const encryptedChar = textChar ^ keyChar;
                result += String.fromCharCode(encryptedChar);
            }
            
            return btoa(result);
        }

        function decryptText(encryptedText, key) {
            if (!encryptedText || !key) return encryptedText;
            
            try {
                const decoded = atob(encryptedText);
                let result = '';
                const keyHash = simpleHash(key);
                
                for (let i = 0; i < decoded.length; i++) {
                    const encryptedChar = decoded.charCodeAt(i);
                    const keyChar = keyHash.charCodeAt(i % keyHash.length);
                    const decryptedChar = encryptedChar ^ keyChar;
                    result += String.fromCharCode(decryptedChar);
                }
                
                return result;
            } catch (error) {
                debugLogger.log('error', 'security', 'Decryption failed', { error: error.message });
                return '[CORRUPTED DATA]';
            }
        }

        let currentMasterPassword = null;

        function setCurrentMasterPassword(password) {
            currentMasterPassword = password;
        }

        function getCurrentEncryptionKey() {
            return currentMasterPassword || '';
        }

        function getDecryptedCellContent(cellNumber) {
            const encryptedContent = config.cells[cellNumber];
            if (!encryptedContent) return '';
            
            if (encryptedContent.startsWith('ENC:')) {
                const encrypted = encryptedContent.substring(4);
                return decryptText(encrypted, getCurrentEncryptionKey());
            }
            
            return encryptedContent;
        }

        function setEncryptedCellContent(cellNumber, content) {
            if (!content) {
                config.cells[cellNumber] = '';
                return;
            }
            
            const key = getCurrentEncryptionKey();
            if (key) {
                config.cells[cellNumber] = 'ENC:' + encryptText(content, key);
                debugLogger.log('info', 'security', `Cell ${cellNumber} content encrypted`);
            } else {
                config.cells[cellNumber] = content;
                debugLogger.log('warn', 'security', `Cell ${cellNumber} content stored unencrypted - no master password`);
            }
        }

        function isFirstRun() {
            return !config.masterPasswordHash;
        }

        async function setupMasterPassword() {
            if (!isFirstRun()) return;

            debugLogger.log('info', 'security', 'Setting up master password for first run');

            const password = await showDialog(
                '🔐 Security Setup',
                'Create a master password to secure your data...',
                ''
            );

            if (!password || password.length < 4) {
                showToast('Password must be at least 4 characters', 'error');
                setTimeout(setupMasterPassword, 1000);
                return;
            }

            const confirmPassword = await showDialog(
                '🔐 Confirm Password',
                'Re-enter your master password...',
                ''
            );

            if (password !== confirmPassword) {
                showToast('Passwords do not match', 'error');
                setTimeout(setupMasterPassword, 1000);
                return;
            }

            config.masterPasswordHash = simpleHash(password);
            config.sessionStartTime = Date.now();
            
            setCurrentMasterPassword(password);
            migrateDataToEncrypted();
            
            saveConfig();
            startLockTimer();
            startSessionTimer();
            showToast('Security enabled! Data is now encrypted.', 'success');
            debugLogger.log('success', 'security', 'Master password setup completed');
        }

        function migrateDataToEncrypted() {
            const key = getCurrentEncryptionKey();
            if (!key) return;
            
            let migrated = false;
            
            for (let cellNumber in config.cells) {
                const content = config.cells[cellNumber];
                if (content && !content.startsWith('ENC:')) {
                    config.cells[cellNumber] = 'ENC:' + encryptText(content, key);
                    migrated = true;
                }
            }
            
            if (migrated) {
                saveConfig();
                showToast('Data migrated to encrypted storage', 'success');
                debugLogger.log('success', 'security', 'Data migration to encrypted storage completed');
            }
        }

        function lockApp() {
            config.isLocked = true;
            setCurrentMasterPassword(null);
            
            document.getElementById('lock-screen').style.display = 'flex';
            document.getElementById('lock-password').focus();
            clearTimers();
            showToast('App locked for security', 'warning');
            debugLogger.log('info', 'security', 'App locked');
        }

        function lockAppNow() {
            closeSecuritySettings();
            lockApp();
        }

        function attemptUnlock() {
            const password = document.getElementById('lock-password').value;
            const hashedInput = simpleHash(password);

            if (hashedInput === config.masterPasswordHash) {
                setCurrentMasterPassword(password);
                unlockApp();
            } else {
                showLockError('Incorrect password. Please try again.');
                document.getElementById('lock-password').value = '';
                document.getElementById('lock-password').focus();
                debugLogger.log('warn', 'security', 'Unlock attempt failed - incorrect password');
            }
        }

        function unlockApp() {
            config.isLocked = false;
            config.sessionStartTime = Date.now();
            document.getElementById('lock-screen').style.display = 'none';
            document.getElementById('lock-password').value = '';
            hideLockError();
            
            for (let i = 1; i <= 9; i++) {
                updateCellDisplay(i);
            }
            
            updatePrivacyUI();
            updateNotepadDisplay();
            
            startLockTimer();
            startSessionTimer();
            showToast('Welcome back! Session renewed.', 'success');
            debugLogger.log('success', 'security', 'App unlocked successfully');
        }

        function showLockError(message) {
            const errorElement = document.getElementById('lock-error');
            errorElement.textContent = message;
            errorElement.classList.add('show');
        }

        function hideLockError() {
            const errorElement = document.getElementById('lock-error');
            errorElement.classList.remove('show');
        }

        function startLockTimer() {
            clearTimeout(lockTimer);
            const timeoutMs = config.lockTimeout * 60 * 1000;
            
            lockTimer = setTimeout(() => {
                if (!config.isLocked) {
                    lockApp();
                }
            }, timeoutMs);
            
            debugLogger.log('debug', 'security', `Lock timer started: ${config.lockTimeout} minutes`);
        }

        function resetLockTimer() {
            if (!config.isLocked && config.masterPasswordHash) {
                startLockTimer();
            }
        }

        function startSessionTimer() {
            clearInterval(sessionTimer);
            sessionTimer = setInterval(updateSessionDisplay, 60000);
            updateSessionDisplay();
        }

        function updateSessionDisplay() {
            if (!config.sessionStartTime) return;
            
            const now = Date.now();
            const sessionMinutes = Math.floor((now - config.sessionStartTime) / 60000);
            const hours = Math.floor(sessionMinutes / 60);
            const minutes = sessionMinutes % 60;
            
            let timeText = '';
            if (hours > 0) {
                timeText = `${hours}h ${minutes}m`;
            } else {
                timeText = `${minutes}m`;
            }
            
            const sessionElement = document.getElementById('session-time');
            if (sessionElement) {
                sessionElement.textContent = timeText;
            }
        }

        function clearTimers() {
            clearTimeout(lockTimer);
            clearInterval(sessionTimer);
            clearClipboardTimers();
            debugLogger.log('debug', 'timers', 'All timers cleared');
        }

        // Privacy and Content Masking Functions
        function maskText(text, showLength = true) {
            if (!text || !config.maskContent) return text;
            
            const length = text.length;
            if (length === 0) return text;
            
            const bullets = '•'.repeat(Math.min(length, 12));
            
            if (showLength && length > 12) {
                return `${bullets} (${length} chars)`;
            }
            
            return bullets;
        }

        function toggleContentMasking() {
            config.maskContent = !config.maskContent;
            updatePrivacyUI();
            updateNotepadDisplay();
            
            for (let i = 1; i <= 9; i++) {
                updateCellDisplay(i);
            }
            
            saveConfig();
            
            debugLogger.log('info', 'privacy', `Content masking ${config.maskContent ? 'enabled' : 'disabled'}`);
            
            if (config.maskContent) {
                showToast('Content masking enabled - click items to peek', 'success');
            } else {
                showToast('Content masking disabled - content visible', 'warning');
            }
        }

        function updatePrivacyUI() {
            const privacyIcon = document.getElementById('privacy-icon');
            const privacyLabel = document.getElementById('privacy-label');
            const privacyToggle = document.querySelector('.privacy-toggle');
            
            if (config.maskContent) {
                privacyIcon.textContent = '🙈';
                privacyLabel.textContent = 'Hide';
                privacyToggle.classList.add('enabled');
            } else {
                privacyIcon.textContent = '👁️';
                privacyLabel.textContent = 'Show';
                privacyToggle.classList.remove('enabled');
            }
        }

        function revealContentTemporarily(element, originalContent, entryId = null) {
            if (!config.maskContent) return;
            
            const timerId = entryId || element.dataset.revealId || Math.random().toString(36);
            if (revealTimers.has(timerId)) {
                clearTimeout(revealTimers.get(timerId));
                revealTimers.delete(timerId);
            }
            
            element.dataset.revealId = timerId;
            
            element.innerHTML = escapeHtml(originalContent);
            element.classList.add('revealed-content');
            element.classList.remove('masked-content');
            
            const peekIndicator = document.createElement('div');
            peekIndicator.className = 'peek-indicator';
            peekIndicator.textContent = 'PEEK';
            element.style.position = 'relative';
            element.appendChild(peekIndicator);
            
            const timer = setTimeout(() => {
                if (element && element.parentNode) {
                    element.innerHTML = `<span class="masked-content">${maskText(originalContent)}</span>`;
                    element.classList.remove('revealed-content');
                    element.classList.add('masked-content');
                    
                    const maskedSpan = element.querySelector('.masked-content');
                    if (maskedSpan) {
                        maskedSpan.addEventListener('click', (e) => {
                            e.stopPropagation();
                            revealContentTemporarily(element, originalContent, timerId);
                        });
                    }
                }
                revealTimers.delete(timerId);
            }, config.peekDuration);
            
            revealTimers.set(timerId, timer);
            
            showToast(`Peeking for ${config.peekDuration/1000} seconds...`, 'warning');
            debugLogger.log('debug', 'privacy', 'Content revealed temporarily', { duration: config.peekDuration });
        }

        function showPeekTooltip(event, content) {
            if (!config.maskContent) return;
            
            const tooltip = document.getElementById('peek-tooltip');
            const preview = content.substring(0, 30) + (content.length > 30 ? '...' : '');
            
            tooltip.textContent = `Preview: ${preview}`;
            tooltip.style.left = event.pageX + 'px';
            tooltip.style.top = (event.pageY - 40) + 'px';
            tooltip.classList.add('show');
        }

        function hidePeekTooltip() {
            const tooltip = document.getElementById('peek-tooltip');
            tooltip.classList.remove('show');
        }

        // Security Settings Functions
        function showSecuritySettings() {
            if (config.isLocked) {
                showToast('Unlock the app first', 'error');
                return;
            }

            document.getElementById('security-settings').style.display = 'flex';
            document.getElementById('lock-timeout-range').value = config.lockTimeout;
            document.getElementById('mask-content-checkbox').checked = config.maskContent;
            document.getElementById('mask-clipboard-checkbox').checked = config.maskClipboard;
            document.getElementById('peek-duration-range').value = config.peekDuration;
            
            updateTimeoutDisplay();
            updateSessionDisplay();
            updateEncryptionStatus();
            updatePeekDurationDisplay();
            updateClipboardStatusDisplay();
            
            debugLogger.log('info', 'ui', 'Security settings dialog shown');
        }

        function closeSecuritySettings() {
            document.getElementById('security-settings').style.display = 'none';
            document.getElementById('current-password').value = '';
            document.getElementById('new-password').value = '';
            document.getElementById('confirm-password').value = '';
            debugLogger.log('info', 'ui', 'Security settings dialog closed');
        }

        function updateTimeoutDisplay() {
            const value = document.getElementById('lock-timeout-range').value;
            const hours = Math.floor(value / 60);
            const minutes = value % 60;
            
            let display = '';
            if (hours > 0) {
                display = `${hours}h ${minutes}m`;
            } else {
                display = `${minutes} minutes`;
            }
            
            document.getElementById('timeout-value').textContent = display;
        }

        function updatePeekDurationDisplay() {
            const value = document.getElementById('peek-duration-range').value;
            const seconds = Math.round(value / 1000);
            document.getElementById('peek-duration-value').textContent = `${seconds}s`;
        }

        function updateEncryptionStatus() {
            let encryptedCount = 0;
            let totalCells = 0;
            
            for (let cellNumber in config.cells) {
                const content = config.cells[cellNumber];
                if (content && content.trim()) {
                    totalCells++;
                    if (content.startsWith('ENC:')) {
                        encryptedCount++;
                    }
                }
            }
            
            const statusElement = document.getElementById('encryption-status');
            if (statusElement) {
                if (totalCells === 0) {
                    statusElement.textContent = 'No cell content stored yet.';
                    statusElement.style.color = 'var(--text-secondary)';
                } else if (encryptedCount === totalCells) {
                    statusElement.textContent = `✅ All ${totalCells} cells encrypted and secure.`;
                    statusElement.style.color = 'var(--success)';
                } else {
                    statusElement.textContent = `⚠️ ${encryptedCount}/${totalCells} cells encrypted. ${totalCells - encryptedCount} cells need migration.`;
                    statusElement.style.color = 'var(--warning)';
                }
            }
        }

        function saveSecuritySettings() {
            const currentPassword = document.getElementById('current-password').value;
            const newPassword = document.getElementById('new-password').value;
            const confirmPassword = document.getElementById('confirm-password').value;
            const newTimeout = parseInt(document.getElementById('lock-timeout-range').value);
            
            const maskContent = document.getElementById('mask-content-checkbox').checked;
            const maskClipboard = document.getElementById('mask-clipboard-checkbox').checked;
            const peekDuration = parseInt(document.getElementById('peek-duration-range').value);

            config.lockTimeout = newTimeout;
            config.maskContent = maskContent;
            config.maskClipboard = maskClipboard;
            config.peekDuration = peekDuration;

            if (currentPassword && newPassword) {
                if (simpleHash(currentPassword) !== config.masterPasswordHash) {
                    showToast('Current password is incorrect', 'error');
                    return;
                }

                if (newPassword !== confirmPassword) {
                    showToast('New passwords do not match', 'error');
                    return;
                }

                if (newPassword.length < 4) {
                    showToast('New password must be at least 4 characters', 'error');
                    return;
                }

                const oldKey = getCurrentEncryptionKey();
                const newKey = newPassword;
                
                for (let cellNumber in config.cells) {
                    const content = config.cells[cellNumber];
                    if (content && content.startsWith('ENC:')) {
                        const decrypted = decryptText(content.substring(4), oldKey);
                        if (decrypted !== '[CORRUPTED DATA]') {
                            config.cells[cellNumber] = 'ENC:' + encryptText(decrypted, newKey);
                        }
                    }
                }

                config.masterPasswordHash = simpleHash(newPassword);
                setCurrentMasterPassword(newPassword);
                showToast('Password changed successfully - data re-encrypted', 'success');
                debugLogger.log('success', 'security', 'Master password changed and data re-encrypted');
            }

            saveConfig();
            startLockTimer();
            
            updatePrivacyUI();
            updateNotepadDisplay();
            for (let i = 1; i <= 9; i++) {
                updateCellDisplay(i);
            }
            
            closeSecuritySettings();
            showToast('Security & privacy settings saved', 'success');
            debugLogger.log('success', 'settings', 'Security settings saved');
        }

        // Clipboard Management Functions
        function initializeClipboardManagement() {
            if (!config.clipboardCreatedTime) {
                config.clipboardCreatedTime = Date.now();
                saveConfig();
            }
            
            startClipboardTimers();
            updateClipboardTimer();
            debugLogger.log('info', 'clipboard', 'Clipboard management initialized');
        }

        function startClipboardTimers() {
            clearClipboardTimers();
            
            if (!config.clipboardCreatedTime || config.clipboardHistory.length === 0) {
                return;
            }
            
            const now = Date.now();
            const elapsed = now - config.clipboardCreatedTime;
            const remainingTime = config.clipboardMaxAge - elapsed;
            const warningTime = remainingTime - config.clipboardWarningTime;
            
            if (remainingTime <= 0) {
                autoClearClipboard();
                return;
            }
            
            if (warningTime <= 0 && !config.clipboardWarningShown) {
                showClipboardWarning();
            } else if (warningTime > 0) {
                clipboardWarningTimer = setTimeout(() => {
                    showClipboardWarning();
                }, warningTime);
            }
            
            clipboardTimer = setTimeout(() => {
                autoClearClipboard();
            }, remainingTime);
            
            clipboardCountdownInterval = setInterval(updateClipboardTimer, 1000);
            
            debugLogger.log('debug', 'clipboard', 'Clipboard timers started', { remainingTime, warningTime });
        }

        function clearClipboardTimers() {
            clearTimeout(clipboardTimer);
            clearTimeout(clipboardWarningTimer);
            clearInterval(clipboardCountdownInterval);
        }

        function updateClipboardTimer() {
            const timerElement = document.getElementById('clipboard-timer');
            if (!timerElement || !config.clipboardCreatedTime || config.clipboardHistory.length === 0) {
                if (timerElement) {
                    timerElement.textContent = 'Clipboard empty - no auto-clear scheduled';
                }
                return;
            }
            
            const now = Date.now();
            const elapsed = now - config.clipboardCreatedTime;
            const remaining = Math.max(0, config.clipboardMaxAge - elapsed);
            
            if (remaining === 0) {
                timerElement.textContent = 'Clipboard expired - clearing...';
                return;
            }
            
            const hours = Math.floor(remaining / (1000 * 60 * 60));
            const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
            
            let timeText = '';
            if (hours > 0) {
                timeText = `${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                timeText = `${minutes}m ${seconds}s`;
            } else {
                timeText = `${seconds}s`;
            }
            
            timerElement.textContent = `Auto-clear in: ${timeText} (${config.clipboardHistory.length} items)`;
        }

        function showClipboardWarning() {
            if (config.clipboardWarningShown) return;
            
            config.clipboardWarningShown = true;
            saveConfig();
            
            const warning = document.getElementById('clipboard-warning');
            warning.classList.add('show');
            
            const countdownElement = document.getElementById('warning-countdown');
            const warningCountdown = setInterval(() => {
                const now = Date.now();
                const elapsed = now - config.clipboardCreatedTime;
                const remaining = Math.max(0, config.clipboardMaxAge - elapsed);
                
                if (remaining === 0) {
                    clearInterval(warningCountdown);
                    countdownElement.textContent = 'Clearing now...';
                    return;
                }
                
                const minutes = Math.floor(remaining / (1000 * 60));
                const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
                
                if (minutes > 0) {
                    countdownElement.textContent = `${minutes}m ${seconds}s`;
                } else {
                    countdownElement.textContent = `${seconds} seconds`;
                }
            }, 1000);
            
            showToast('🚨 Clipboard will auto-clear in 30 minutes!', 'warning');
            debugLogger.log('warn', 'clipboard', 'Clipboard auto-clear warning shown');
        }

        function dismissClipboardWarning() {
            const warning = document.getElementById('clipboard-warning');
            warning.classList.remove('show');
            debugLogger.log('info', 'clipboard', 'Clipboard warning dismissed');
        }

        function postponeClipboardClear() {
            const extension = 2 * 60 * 60 * 1000;
            config.clipboardCreatedTime += extension;
            config.clipboardWarningShown = false;
            saveConfig();
            
            dismissClipboardWarning();
            startClipboardTimers();
            
            showToast('Clipboard auto-clear postponed by 2 hours', 'success');
            debugLogger.log('info', 'clipboard', 'Clipboard auto-clear postponed', { extension });
        }

        function autoClearClipboard() {
            clearClipboardHistory(true);
            dismissClipboardWarning();
            showToast('🧹 Clipboard automatically cleared for security', 'warning');
            debugLogger.log('info', 'clipboard', 'Clipboard automatically cleared');
        }

        function clearClipboardHistory(isAutomatic = false) {
            if (!isAutomatic && config.clipboardHistory.length > 0) {
                const confirm = window.confirm(`Clear all ${config.clipboardHistory.length} clipboard items?\n\nThis cannot be undone. Consider exporting first.`);
                if (!confirm) return;
            }
            
            config.clipboardHistory = [];
            config.clipboardCreatedTime = null;
            config.clipboardWarningShown = false;
            
            clearClipboardTimers();
            updateNotepadDisplay();
            updateClipboardTimer();
            saveConfig();
            
            if (!isAutomatic) {
                showToast('Clipboard history cleared', 'success');
                debugLogger.log('info', 'clipboard', 'Clipboard history manually cleared');
            }
        }

        function exportClipboard() {
            if (config.clipboardHistory.length === 0) {
                showToast('No clipboard history to export', 'warning');
                return;
            }
            
            let exportText = `Oblysk Clipboard Export\n`;
            exportText += `Generated: ${new Date().toLocaleString()}\n`;
            exportText += `Total items: ${config.clipboardHistory.length}\n`;
            exportText += `\n${'='.repeat(50)}\n\n`;
            
            config.clipboardHistory.forEach((entry, index) => {
                exportText += `[${index + 1}] ${entry.timestamp}\n`;
                exportText += `Type: ${entry.type}\n`;
                exportText += `Source: ${entry.source || 'unknown'}\n`;
                if (entry.type === 'image') {
                    exportText += `Content: [Image data - not exported]\n`;
                } else {
                    exportText += `Content: ${entry.content}\n`;
                }
                exportText += `\n${'-'.repeat(30)}\n\n`;
            });
            
            document.getElementById('export-preview').textContent = exportText.substring(0, 1000) + (exportText.length > 1000 ? '\n\n... (preview truncated)' : '');
            document.getElementById('export-modal').style.display = 'flex';
            
            window.clipboardExportContent = exportText;
            debugLogger.log('info', 'clipboard', 'Export modal shown', { itemCount: config.clipboardHistory.length });
        }

        function exportBeforeClear() {
            exportClipboard();
            showToast('Export clipboard before it gets cleared', 'warning');
        }

        function closeExportModal() {
            document.getElementById('export-modal').style.display = 'none';
        }

        function downloadExport() {
            const content = window.clipboardExportContent || 'No content to export';
            const filename = `oblysk-clipboard-${new Date().toISOString().split('T')[0]}.txt`;
            
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            closeExportModal();
            showToast(`Clipboard exported as ${filename}`, 'success');
            debugLogger.log('success', 'clipboard', 'Clipboard exported', { filename });
        }

        function showClipboardStatus() {
            if (config.clipboardHistory.length === 0) {
                showToast('Clipboard is empty', 'info');
                return;
            }
            
            const now = Date.now();
            const elapsed = now - config.clipboardCreatedTime;
            const remaining = Math.max(0, config.clipboardMaxAge - elapsed);
            
            const hours = Math.floor(remaining / (1000 * 60 * 60));
            const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
            
            let statusText = `📊 Clipboard Status:\n`;
            statusText += `• ${config.clipboardHistory.length} items stored\n`;
            statusText += `• Created: ${new Date(config.clipboardCreatedTime).toLocaleString()}\n`;
            statusText += `• Auto-clear in: ${hours}h ${minutes}m\n`;
            statusText += `• Warning shown: ${config.clipboardWarningShown ? 'Yes' : 'No'}`;
            
            alert(statusText);
            debugLogger.log('info', 'clipboard', 'Status shown to user');
        }

        function updateClipboardStatusDisplay() {
            const statusElement = document.getElementById('clipboard-status-display');
            if (!statusElement) return;
            
            if (config.clipboardHistory.length === 0) {
                statusElement.textContent = 'Clipboard is empty - no auto-clear scheduled';
                statusElement.style.color = 'var(--text-secondary)';
                return;
            }
            
            const now = Date.now();
            const elapsed = now - config.clipboardCreatedTime;
            const remaining = Math.max(0, config.clipboardMaxAge - elapsed);
            
            const hours = Math.floor(remaining / (1000 * 60 * 60));
            const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
            
            statusElement.textContent = `${config.clipboardHistory.length} items • Auto-clear in ${hours}h ${minutes}m`;
            
            if (remaining < config.clipboardWarningTime) {
                statusElement.style.color = 'var(--warning)';
            } else {
                statusElement.style.color = 'var(--text-secondary)';
            }
        }

        // Global error handling
        window.addEventListener('error', (event) => {
            debugLogger.log('error', 'window', 'Global error caught', { 
                message: event.error?.message, 
                filename: event.filename, 
                lineno: event.lineno,
                stack: event.error?.stack 
            });
            setStatus('error', 'JavaScript error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            debugLogger.log('error', 'window', 'Unhandled promise rejection', { 
                reason: event.reason,
                stack: event.reason?.stack 
            });
            setStatus('error', 'Promise rejection');
        });

        window.addEventListener('beforeunload', () => {
            clearTimers();
            saveConfig();
            debugLogger.log('info', 'window', 'App unloading - cleanup completed');
        });

        // Make functions globally available for console debugging and IPC
        window.debugLogger = debugLogger;
        window.testDialog = async () => {
            const result = await showDialog('Test Dialog', 'Enter test value', 'default value');
            console.log('Dialog result:', result);
            showToast(`Dialog returned: ${result}`, 'success');
        };
        window.editCellName = editCellName;
        window.editCellContent = editCellContent;
        window.pasteOnDeck = pasteOnDeck;
        window.toggleAutoCapture = toggleAutoCapture;
        window.showDevInfo = showDevInfo;
        window.showSecuritySettings = showSecuritySettings;
        window.lockAppNow = lockAppNow;
        window.migrateDataToEncrypted = migrateDataToEncrypted;
        window.toggleContentMasking = toggleContentMasking;
        window.revealContentInContainer = function(containerId, encodedContent) {
            try {
                const content = atob(encodedContent);
                const container = document.getElementById(containerId);
                if (container) {
                    revealContentTemporarily(container, content, containerId);
                }
            } catch (error) {
                debugLogger.log('error', 'privacy', 'Failed to reveal content', { error: error.message });
                showToast('Failed to reveal content', 'error');
            }
        };
        window.revealClipboardEntry = revealClipboardEntry;
        window.showPeekTooltip = showPeekTooltip;
        window.hidePeekTooltip = hidePeekTooltip;
        window.exportClipboard = exportClipboard;
        window.clearClipboardHistory = clearClipboardHistory;
        window.showClipboardStatus = showClipboardStatus;
        window.exportBeforeClear = exportBeforeClear;
        window.postponeClipboardClear = postponeClipboardClear;
        window.dismissClipboardWarning = dismissClipboardWarning;
        window.closeExportModal = closeExportModal;
        window.downloadExport = downloadExport;
        window.showReversePanel = showReversePanel;
        window.closeReversePanel = closeReversePanel;
        window.toggleReverseCapture = toggleReverseCapture;
        window.testReverseCapture = testReverseCapture;
        window.attemptUnlock = attemptUnlock;
        window.minimizeApp = minimizeApp;
        window.closeApp = closeApp;
        window.openEmail = openEmail;
        window.openWebsite = openWebsite;
        window.openDonate = openDonate;
        window.closeDialog = closeDialog;
        window.closeDevInfo = closeDevInfo;
        window.closeSecuritySettings = closeSecuritySettings;
        window.saveSecuritySettings = saveSecuritySettings;
        window.toggleGrid = toggleGrid;

        debugLogger.log('success', 'startup', '✓ Oblysk script loaded with enhanced debugging and reverse copy');
    </script>
</body>
</html>